# **Билеты Питон 1 семестр**

#### От Авторов
Друзья-джан, кайфуйте и наслаждайтесь, ботайте питон и ни в чем себе не отказывайте, дерзайте знать! Сея билеты были сделаны дабы сэкономить ваше время, шарясь в gptшках, документациях и подобном. Всем успешного зачета!!! 
**Отдельная благодарность за составление билетов: Тарасову Аким гр.414, Шарафутдинову Руслану гр. 415**

# Основы языка

## 1. Структура языка. Физические и логические строки, простые и составные инструкции. Токены: литералы, идентификаторы, разделители, операторы, ключевые слова.

#### 1. Структура языка Python: 
Python — интерпретируемый, объектно-ориентированный язык с динамической типизацией. Его структура основана на отступах (пробелы в начале строки), а не на фигурных скобках как в C++ или Java. Это делает код более читаемым, но требует аккуратности с отступами.

#### 2. Физические и логические строки:
Физическая строка: Строка кода, которую вы пишете в редакторе. Она заканчивается нажатием Enter.
Логическая строка: Строка кода, которую интерпретатор Python обрабатывает как одну инструкцию. Несколько физических строк могут образовывать одну логическую строку (например, при использовании обратного слэша \ в конце строки).

```python
#Одна физическая и одна логическая строка
print("Hello, world!")

#Две физические, но одна логическая строка
print("This is a long string" \
      "that spans multiple lines.")
```

#### 3. Простые и составные инструкции:
Простая инструкция: Выполняет одно действие. Например, присваивание значения переменной (x = 5), вывод на экран (print("Hello")), вызов функции.
Составная инструкция: Группа простых инструкций, объединенных в блок. Определяется отступами. Примеры: if, elif, else, for, while, def (определение функции), class (определение класса).

```python
# Простая инструкция
x = 10

# Составная инструкция (условный оператор)
if x > 5:
    print("x больше 5")
    y = x * 2  # Еще одна простая инструкция внутри составной
else:
    print("x не больше 5")
```

#### 4. Токены: Это основные строительные блоки программы Python
1) Литералы: Конкретные значения, например, числа (10, 3.14), строки ("Hello"), булевы значения (True, False).
2) Идентификаторы: Имена, которые вы даете переменным, функциям, классам. Должны начинаться с буквы или подчеркивания, могут содержать буквы, цифры и подчеркивания. Регистр важен (myVariable и myvariable — разные имена).
3) Разделители: Символы, которые отделяют токены друг от друга, например, пробелы, запятые, точки с запятой (хотя в Python точка с запятой часто необязательна).
4) Операторы: Символы или ключевые слова, которые выполняют операции, например, +, -, *, /, =, ==, >, <, and, or, not.
5) Ключевые слова: Зарезервированные слова, имеющие специальное значение в Python, например, if, else, for, while, def, class, return, import, True, False, None.

## 2. Объекты  Python  и  их  основные  характеристики:  идентичность, тип данных и значение. Встроенная функция id() и оператор is.

#### 1. Объекты в Python
В Python все является объектом. Объекты – это фундаментальные сущности, хранящие данные (значение) и имеющие определенный тип. Они обладают тремя основными характеристиками:

#### 2. Идентичность (Identity): 
Уникальный номер, присваиваемый каждому объекту при его создании. Он остается неизменным в течение всего времени существования объекта. Вы можете получить идентификатор объекта с помощью встроенной функции id().

#### 3. Тип данных (Type): 
Определяет, какие операции можно выполнять с объектом и как он хранится в памяти. Примеры типов данных: int, float, str, list, dict, tuple и т.д. Тип объекта можно получить с помощью функции type().

#### 4. Значение (Value): 
Данные, которые хранит объект. Например, для объекта типа int значением будет целое число, для объекта типа str — строка символов.

#### 5. Встроенная функция id(): 
Возвращает уникальный целочисленный идентификатор объекта.
```python
x = 10
y = 10
z = [1, 2, 3]

print(id(x))  # Выведет идентификатор объекта x
print(id(y))  # Выведет идентификатор объекта y (может быть тот же, что и у x, см. ниже)
print(id(z))  # Выведет идентификатор объекта z (будет отличаться от x и y)
```
Обратите внимание, что id(x) и id(y) могут быть одинаковыми, поскольку Python часто повторно использует объекты для небольших целых чисел для оптимизации памяти (интернирование).

#### 6. Оператор is: 
Сравнивает идентичность объектов. Он возвращает True, если два объекта имеют один и тот же идентификатор, и False в противном случае. Это отличается от оператора `==`, который сравнивает значения объектов.
```python
x = 10
y = 10
z = [1, 2, 3]
w = [1, 2, 3]

print(x is y)  # Может быть True (из-за интернирования)
print(x == y)  # True (значения равны)
print(z is w)  # False (разные объекты, даже если значения равны)
print(z == w)  # True (значения равны)
```

## 3. Понятия изменяемых и неизменяемых типов данных. Оператор связывания (=). Переменные в Python и ссылочная модель памяти. 

#### 1. Изменяемые и неизменяемые типы данных:
В Python типы данных делятся на изменяемые (mutable) и неизменяемые (immutable).
Неизменяемые типы: Значение объекта после создания не может быть изменено. Если кажется, что вы изменяете неизменяемый объект, на самом деле создается новый объект с измененным значением. Примеры: int, float, bool, str, tuple.
Изменяемые типы: Значение объекта может быть изменено после создания. Примеры: list, dict, set.

```python
# Неизменяемый тип (строка)
my_string = "hello"
#my_string[0] = "H"  # Это вызовет ошибку TypeError

new_string = "H" + my_string[1:] # Создается новый объект
print(new_string) # Выведет "Hello"

# Изменяемый тип (список)
my_list = [1, 2, 3]
my_list[0] = 10  # Изменяем значение на месте
print(my_list)  # Выведет [10, 2, 3]
```

#### 2. Оператор связывания (=):
Оператор = в Python не является оператором копирования в прямом смысле. Он создает связь (ссылку) между переменной и объектом. В случае неизменяемых типов это не так критично, а в случае изменяемых типов это очень важно понимать.

#### 3. Переменные в Python и ссылочная модель памяти:
Python использует ссылочную модель памяти. Переменная – это просто имя (метка), которое указывает на объект в памяти.

```python
x = [1, 2, 3]
y = x  # y теперь ссылается на тот же объект, что и x
y[0] = 10  # Изменение через y также изменяет x, потому что они ссылаются на один и тот же объект.
print(x)  # Выведет [10, 2, 3]
```

Если нужно создать копию объекта, а не ссылку, нужно использовать функции copy.copy() (для поверхностного копирования. То есть физически создается элемент в памяти, но его элементы - указатели на прежние значения) или copy.deepcopy() (для глубокого копирования. Создается новый объект в памяти, и для каждого элемента объекта создается копия элемента в памяти) из модуля copy.

```python
import copy
x = [1, 2, [3,4]]
y = copy.copy(x) # Поверхностная копия
z = copy.deepcopy(x) # Глубокая копия

y[0] = 10 # Изменяет y, но не x
print(x)  # [1, 2, [3, 4]]
print(y)  # [10, 2, [3, 4]]
y[2][0] = 100 # Изменяет и y и x так как это поверхностная копия
print(x) # [1, 2, [100, 4]]
print(y) # [10, 2, [100, 4]]
z[2][0] = 200 # Изменяет только z так как это глубокая копия
print(x)  # [1, 2, [100, 4]]
print(z) # [1, 2, [200, 4]]
```

## 4. Булев тип данных. Операции над объектами булева типа данных. Синглтоны True, False и None 

#### 1. В Python булев тип данных (bool) представляет собой логическое значение, которое может быть либо True (истина), либо False (ложь). Он используется для представления истинных или ложных условий в программах.

#### 2. Операции над булевыми значениями:
Python поддерживает стандартные логические операции:

1) and (логическое И): Возвращает True, если оба операнда истинны. В противном случае возвращает False.

2) or (логическое ИЛИ): Возвращает True, если хотя бы один из операндов истинен. Возвращает False, только если оба операнда ложны.

3) not (логическое НЕ): Инвертирует булево значение. not True равно False, а not False равно True.

``` python
a = True
b = False

print(a and b)  # False
print(a or b)   # True
print(not a)    # False
print(not b)    # True
```

#### 3.Операторы сравнения:
Операторы сравнения также возвращают булевы значения:

1) ㅤ== (равно): Проверяет равенство значений.
2) ㅤ!= (не равно): Проверяет неравенство значений.
3) ㅤ> (больше):
4) ㅤ< (меньше):
5) ㅤ>= (больше или равно):
6) ㅤ<= (меньше или равно):

```python
x = 5
y = 10
print(x == y)  # False
print(x != y)  # True
print(x < y)   # True
print(x > y)   # False
print(x >= 5)  # True
print(y <= 10) # True
```

#### 4. Булевы значения в условных операторах:
Булевы значения используются в условных операторах if, elif, else для управления потоком выполнения программы:

```python
age = 20

if age >= 18:
    print("Вы совершеннолетний")
else:
    print("Вы несовершеннолетний")
```

#### 5. Преобразование в булево значение:
Любое значение в Python может быть неявно преобразовано в булево значение. В большинстве случаев пустые или нулевые значения (например, 0, 0.0, "", [], {}, None) преобразуются в False, а все остальные — в True. Это называется булевым контекстом.

```python
print(bool(0))      # False
print(bool(1))      # True
print(bool(""))     # False
print(bool("hello")) # True
print(bool([]))     # False
print(bool([1, 2])) # True
print(bool(None))   # False
```

#### 6. Синглтоны True, False, None:
True, False, и None в Python являются синглтонами. Это означает, что существует только один экземпляр каждого из этих объектов в памяти. Любое присваивание x = True не создает новый булев объект True, а просто создает новую ссылку (x) на уже существующий объект True. То же самое относится к False и None.

## 5. Оператор not. Ленивые операторы or и and. 

#### 1. Оператор not
Оператор not в Python используется для логического отрицания. Он меняет булево значение на противоположное:

not True равно False, 
not False равно True

```python
x = True
y = not x
print(y)  # Выведет False

z = False
w = not z
print(w)  # Выведет True
```

#### 2. Ленивые операторы or и and
Операторы or и and в Python являются ленивыми (или кратчайшими). Это означает, что они не вычисляют все операнды, если результат уже известен.

1) and: Если первый операнд равен False, то результат сразу False, и второй операнд не вычисляется. В противном случае, вычисляется второй операнд, и результат равен значению второго операнда.

2) or: Если первый операнд равен True, то результат сразу True, и второй операнд не вычисляется. В противном случае, вычисляется второй операнд, и результат равен значению второго операнда.

```python
def some_function():
  print("Вызов some_function")
  return True

def another_function():
  print("Вызов another_function")
  return False

print(False and some_function())  # Выведет только "Вызов some_function" не будет выводить True or False.
print(True or another_function()) # Выведет только "Вызов some_function" и True, не будет выводить False.
```

#### 3.Пример с не-булевыми значениями:
Ленивость проявляется не только с булевыми значениями, но и с любыми объектами в Python. Если операция требует значения операнда, то оно будет вычислено.

```python
def some_function():
    print("Вызов some_function")
    return 10

def another_function():
    print("Вызов another_function")
    return 0

result = some_function() and another_function() # не будет вызываться another_function(), результат равен 10
print(result)  # выведет 0

result = some_function() or another_function() # не будет вызываться another_function(), результат равен 10
print(result)  # выведет 10
```

## 6. Встроенные функции all() и any(). Примеры использования. Ленивость вычисления. 

#### 1.Функции all() и any():
Функции all() и any() в Python используются для проверки итерируемых объектов (списки, кортежи, множества и т.д.) на основе булевых значений их элементов. Обе функции демонстрируют ленивое вычисление.

1) all(iterable):
Возвращает True, если все элементы итерируемого объекта оцениваются как True в булевом контексте. Если хотя бы один элемент оценивается как False, функция возвращает False. Вычисление останавливается на первом же ложном элементе.

Примеры:
```python
print(all([True, True, True]))  # True
print(all([True, False, True])) # False
print(all([1, 2, 3]))          # True (все числа отличны от 0)
print(all([1, 2, 0]))          # False (0 оценивается как False)
print(all([]))                 # True (пустой итерируемый объект считается истинным)
print(all([True, "abc", 1]))   # True
print(all([True, "", 1]))      # False (пустая строка "" оценивается как False)
```

2) any(iterable):
Возвращает True, если хотя бы один элемент итерируемого объекта оценивается как True в булевом контексте. Если все элементы оцениваются как False, функция возвращает False. Вычисление останавливается на первом же истинном элементе.

Примеры:
```python
print(any([True, True, True]))  # True
print(any([True, False, True])) # True
print(any([False, False, True]))# True
print(any([False, False, False]))# False
print(any([0, 0, 0]))          # False (все числа равны 0)
print(any([0, 0, 1]))          # True (1 оценивается как True)
print(any([]))                 # False (пустой итерируемый объект считается ложным)
```

#### 2. Ленивость вычисления:
Как all(), так и any() используют ленивое вычисление. Они обрабатывают элементы итерируемого объекта по одному, и прекращают вычисление, как только результат становится известен. Это делает их эффективными для работы с очень большими итерируемыми объектами, так как не требуется обрабатывать все элементы, если результат может быть определен раньше.

Пример с ленивостью:
```python
def my_func(x):
  print(f"Вычисляю для {x}")
  return x > 5

numbers = [1, 2, 3, 4, 5, 6, 7, 8]

print(all(my_func(num) for num in numbers)) # Выведет False и выведет сообщения вычисления для 1
print(any(my_func(num) for num in numbers)) # Выведет True и выведет сообщения вычисления для 1,2,3,4,5,6
```
В этом примере, all() прекращает вычисление на числе 1, потому что my_func(1) возвращает False. any() же, наоборот, останавливается на 6 после получения True.

## 7. Управляющие конструкции: различные формы ветвления и цикла while. Ключевые слова break и continue. Примеры использования. 

#### Управляющие конструкции: ветвление и цикл while
Python предлагает несколько способов контролировать порядок выполнения кода, используя управляющие конструкции, такие как ветвление (условные операторы) и циклы.

#### 1. Ветвление:
1) if-else: Проверяет условие. Если оно истинно, выполняется блок кода if. В противном случае, выполняется блок кода else (если он есть). Можно использовать elif для проверки дополнительных условий.

```python
age = 20

if age >= 18:
    print("Вы совершеннолетний")
elif age >= 13:
    print("Вы подросток")
else:
    print("Вы несовершеннолетний")
```

2) Вложенные if: Один if-блок может быть вложен в другой if-блок или elif-блок.

```python
x = 10
y = 5

if x > 5:
    if y > 2:
        print("x > 5 и y > 2")
    else:
        print("x > 5 и y не > 2")
```

#### 2. Цикл while:
Цикл while повторяет блок кода до тех пор, пока условие остается истинным.

```python
i = 0
while i < 5:
    print(i)
    i += 1
``` 
#### 3. Ключевые слова break и continue:
1) break: Используется для выхода из цикла while или for.

```python
i = 0
while True:
    print(i)
    i += 1
    if i == 5:
        break
```

2) continue: Используется для пропуска текущей итерации цикла и перехода к следующей.

```python
i = 0
while i < 10:
    i += 1
    if i % 2 == 0:
        continue  # пропускаем четные числа
    print(i)
``` 

#### 4. Примеры использования:

Пример 1: Проверка на простое число:
```python
num = 17

is_prime = True
for i in range(2, int(num**0.5) + 1):
    if num % i == 0:
        is_prime = False
        break
if is_prime and num > 1:
    print(f"{num} - простое число")
else:
    print(f"{num} - не простое число")
```

Пример 2: Чтение данных до тех пор, пока пользователь не введет “стоп”:
```python
while True:
    user_input = input("Введите текст (или 'стоп' для выхода): ")
    if user_input.lower() == "стоп":
        break
    print("Вы ввели:", user_input)
```

## 8. Числовые типы данных. Основные операции, допустимые значения, численные литералы. 
Python поддерживает несколько числовых типов данных:

#### 1. Целые числа (int):
Допустимые значения: Любое целое число, ограниченное только доступной памятью компьютера (практически неограниченно).
Численные литералы: Записываются без десятичной точки, например, 10, -5, 0, 1000000.
Основные операции: +, -, \*, /, // (целочисленное деление), % (остаток от деления), ** (возведение в степень).

```python
x = 10
y = 3
print(x + y)  # 13
print(x - y)  # 7
print(x * y)  # 30
print(x / y)  # 3.3333333333333335
print(x // y) # 3
print(x % y)  # 1
print(x ** y) # 1000
```

#### 2. Числа с плавающей точкой (float):
Допустимые значения: Вещественные числа, представляемые в формате с плавающей точкой (с десятичной точкой).
Численные литералы: Записываются с десятичной точкой, например, 3.14, -2.5, 0.0, 1e6 (экспоненциальная запись).
Основные операции: Те же, что и для целых чисел. Деление / всегда возвращает число с плавающей точкой.

```python 
x = 3.14
y = 2.0
print(x + y)  # 5.14
print(x * y)  # 6.28
print(x / y)  # 1.57
```

#### 3. Комплексные числа (complex):
Допустимые значения: Числа в форме `a + jb`, где a — действительная часть, b — мнимая часть, j — мнимая единица. 
Численные литералы: Записываются с использованием j или J для обозначения мнимой части, например, `3 + j2`, `-j1`.
Основные операции: Те же, что и для других числовых типов.

```python 
x = 3 + 2j
y = 1 - 1j
print(x + y)  # (4+1j)
print(x * y)  # (5+5j)
``` 

#### 4. Ограничения:
Переполнение: при работе с очень большими числами может возникнуть переполнение (overflow).
Точность: числа с плавающей точкой имеют ограниченную точность. Некоторые вычисления могут давать небольшие ошибки округления.
Преобразование типов: можно преобразовывать числовые типы данных друг в друга с помощью функций int(), float(), и complex().

```python
x = 10
y = float(x)  # Преобразование int в float
print(y) # 10.0

z = complex(x) # Преобразование int в complex
print(z) # (10+0j)

a = 3.14
b = int(a) # Преобразование float в int (округление вниз)
print(b) # 3

c = 5+3j
d = float(c) # Преобразование complex в float (возникнет ошибка)
``` 

## 9. Кортежи и операции над ними. Обход ограничения на неизменяемость элементов. Основные методы. 

#### 1. Кортежи 
Кортежи (tuples) в Python — это упорядоченные, неизменяемые коллекции элементов. Они похожи на списки, но их элементы нельзя изменять после создания. Это делает их подходящими для представления данных, которые не должны изменяться.

Создание кортежей:
Кортежи создаются с помощью круглых скобок (). Если в кортеже только один элемент, необходимо добавить запятую после него, чтобы отличить его от выражения в скобках:
```python
empty_tuple = ()
single_element_tuple = (1,)  # Запятая обязательна
tuple_with_elements = (1, 2, "hello", 3.14)
```
Можно также создавать кортежи без скобок (в данном случае это “распаковка”):
```python
a = 1,2,3 # Это тоже кортеж
print(type(a)) #<class 'tuple'>
```

#### 2. Операции над кортежами:
Доступ к элементам: К элементам кортежа можно обращаться по индексу (как и в списках), начиная с 0.
```python
my_tuple = (1, 2, 3, 4, 5)
print(my_tuple[0])  # 1
print(my_tuple[-1]) # 5 (последний элемент)
```
Срезы (slices): Можно извлекать подпоследовательности элементов.
```python
print(my_tuple[1:4])  # (2, 3, 4)
print(my_tuple[:3])   # (1, 2, 3)
print(my_tuple[2:])   # (3, 4, 5)
```
Конкатенация: Можно объединять кортежи с помощью оператора `+`.
```python
tuple1 = (1, 2)
tuple2 = (3, 4)
print(tuple1 + tuple2)  # (1, 2, 3, 4)
```
Повторение: Можно повторять кортежи с помощью оператора \*.
```python
print(tuple1 * 3)  # (1, 2, 1, 2, 1, 2)
```
Проверка вхождения: Оператор `in` проверяет, содержится ли элемент в кортеже.
```python
print(3 in tuple2)  # True
print(5 in tuple2)  # False
```
Длина кортежа: Функция `len()` возвращает количество элементов в кортеже.
```python
print(len(my_tuple))  # 5
```
#### 3. Обход ограничения на неизменяемость:
Хотя сами кортежи неизменяемы, если элементы кортежа - изменяемые объекты (например, списки), то эти внутренние элементы можно изменять.

```python
my_tuple = ([1, 2], 3)
my_tuple[0].append(3)  # Изменяем список внутри кортежа
print(my_tuple)  # ([1, 2, 3], 3)
```

#### 4. Основные методы:
Кортежи имеют относительно мало встроенных методов, в отличие от списков. Основные — это:

1) count(x): Возвращает количество вхождений элемента x в кортеже.
2) index(x): Возвращает индекс первого вхождения элемента x в кортеже. Вызывает исключение ValueError, если элемент не найден.

```python
my_tuple = (1, 2, 2, 3, 2)
print(my_tuple.count(2))  # 3
print(my_tuple.index(2))  # 1
```


## 10. Списки и операции над ними. Основные методы. Ошибки при построении списков через повторение с пояснением сути ошибки. 

#### 1. Списки 
Списки (lists) в Python — это упорядоченные, изменяемые коллекции элементов. Они являются одной из самых распространенных и гибких структур данных.

Создание списков:
Списки создаются с помощью квадратных скобок `[]`. Элементы разделяются запятыми.

```python
empty_list = []
list_with_elements = [1, 2, "hello", 3.14, True]
```

#### 2. Операции над списками:
Доступ к элементам: К элементам списка можно обращаться по индексу (как и в кортежах), начиная с 0.
```python
my_list = [10, 20, 30, 40, 50]
print(my_list[0])  # 10
print(my_list[-1]) # 50 (последний элемент)
``` 
Срезы (slices): Можно извлекать подпоследовательности элементов.
```python
print(my_list[1:4])  # [20, 30, 40]
print(my_list[:3])   # [10, 20, 30]
print(my_list[2:])   # [30, 40, 50]
```
Изменение элементов: Элементы списка можно изменять.
```python
my_list[0] = 100
print(my_list)  # [100, 20, 30, 40, 50]
```
Добавление элементов:
1) append(x): Добавляет элемент x в конец списка.
2) insert(i, x): Вставляет элемент x в позицию i.
3) extend(iterable): Расширяет список, добавляя все элементы из итерируемого объекта.
```python
my_list.append(60)
my_list.insert(2, 25)
my_list.extend([70, 80])
print(my_list)  # [100, 20, 25, 30, 40, 50, 60, 70, 80]
```
Удаление элементов:
1) `pop([i])`: Удаляет и возвращает элемент с позицией i (по умолчанию, последний).
2) `remove(x)`: Удаляет первое вхождение элемента x.
3) `del my_list[i]`: Удаляет элемент с позицией i.

Конкатенация: Можно объединять списки с помощью оператора `+`.
```python
list1 = [1, 2]
list2 = [3, 4]
print(list1 + list2)  # [1, 2, 3, 4]
```
Повторение: Можно повторять списки с помощью оператора `*`.
```python
print(list1 * 3)  # [1, 2, 1, 2, 1, 2]
```
Проверка вхождения: Оператор `in` проверяет, содержится ли элемент в списке.
```python
print(3 in list2)  # True
```
Длина списка: Функция `len()` возвращает количество элементов в списке.
```python
print(len(my_list))  # 8
```

#### 3. Основные методы:
Помимо операций, рассмотренных выше, списки имеют множество полезных методов: `sort()`, `reverse()`, `copy()`, `clear()` и др. Подробное описание можно найти в документации Python.

#### 4. Ошибки при построении списков через повторение:
Частая ошибка возникает при создании списка путем повторения изменяемого объекта:
```python
my_list = [[0] * 3] * 3
print(my_list)  # [[0, 0, 0], [0, 0, 0], [0, 0, 0]]

my_list[0][0] = 1
print(my_list)  # [[1, 0, 0], [1, 0, 0], [1, 0, 0]]  <- Ошибка!
```
Суть ошибки:
В этом коде создается не три отдельных списка, а три ссылки на один и тот же список `[0, 0, 0]`. Поэтому, изменение одного из “подсписков” изменяет все три.
Чтобы создать три независимых списка, нужно использовать генератор списка:
```python
my_list = [[0] * 3 for _ in range(3)]
print(my_list)  # [[0, 0, 0], [0, 0, 0], [0, 0, 0]]

my_list[0][0] = 1
print(my_list)  # [[1, 0, 0], [0, 0, 0], [0, 0, 0]]  <- Теперь корректно
```
Этот способ создает три отдельных списка, каждый со своей собственной копией `[0, 0, 0]`.

## 11. Цикл for и его различные формы. Инструкции break, continue и else в контексте цикла for. 

#### 1. Цикл for 
Цикл for в Python используется для итерации по последовательностям (списки, кортежи, строки, итерируемые объекты) или по диапазону значений.

Основные формы цикла for:

1) Итерация по последовательности:
```python
my_list = ["apple", "banana", "cherry"]
for fruit in my_list:
    print(fruit)
```
Этот код перебирает каждый элемент списка my_list и присваивает его переменной fruit.

2) Итерация по диапазону:
```python
for i in range(5):  # range(5) генерирует последовательность 0, 1, 2, 3, 4
    print(i)
```
3) Функция `range()` создает последовательность чисел. Можно указать начало, конец и шаг:
```python
for i in range(1, 11, 2):  # от 1 до 10 с шагом 2 (1, 3, 5, 7, 9)
    print(i)
```
4) Итерация по строке:
```python
my_string = "hello"
for char in my_string:
    print(char)
```
Этот код перебирает каждый символ строки.

5) Итерация с индексами:
Для доступа к индексу элемента в цикле for можно использовать функцию `enumerate()`:
```python
my_list = ["apple", "banana", "cherry"]
for index, fruit in enumerate(my_list):
    print(f"Элемент {index}: {fruit}")
```
6) Итерация по нескольким последовательностям (с помощью zip):
`zip()` объединяет несколько итерируемых объектов в один итерируемый объект кортежей.
```python
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 28]

for name, age in zip(names, ages):
    print(f"{name} is {age} years old.")
```

#### 2. break, continue и else в цикле for:
1) `break`: Прерывает цикл for досрочно. Выполнение переходит к коду, следующему за циклом.
```python
for i in range(10):
    if i == 5:
        break
    print(i)  # Выведет 0, 1, 2, 3, 4
```
2) `continue`: Пропускает текущую итерацию цикла и переходит к следующей.
```python
for i in range(10):
    if i % 2 == 0:
        continue  # Пропускаем четные числа
    print(i)  # Выведет 1, 3, 5, 7, 9
```
3) `else`: Блок else в цикле for выполняется только тогда, когда цикл завершился естественным образом (т.е. не был прерван инструкцией break).
```python
for i in range(5):
    print(i)
else:
    print("Цикл завершен") # Выполнится

for i in range(5):
    if i == 3:
        break
    print(i)
else:
    print("Цикл завершен") # Не выполнится
```
Блок `else` часто используется для обработки случая, когда цикл не нашел какого-либо элемента:
```python
my_list = [1, 2, 3, 4, 5]
target = 6

for item in my_list:
    if item == target:
        print(f"Найден элемент: {target}")
        break
else:
    print(f"Элемент {target} не найден")
```

## 12. Строки, виды строк. Основные операции  над  строками: манипуляция с регистром, проверка наличия символов из определенной группы, проверка регистра, очистка строки, разбиение и объединение строк, работа с подстроками. 

#### 1. Строки
В Python строки представляют собой неизменяемые последовательности символов *Unicode*. Хотя Python не имеет различных типов строк в смысле разных классов данных, мы можем классифицировать их по способу определения и обработке:

Способы определения строк:
1) Одинарные кавычки `'...'`: `'Это строка'`
2) Двойные кавычки `"..."`: `"Это тоже строка"`
3) Тройные кавычки (`'''...'''` или `"""..."""`): Для многострочных строк, сохраняющих форматирование. Зачастую используются для комментариев и оформления кода. Умные редакторы кода могут заполнять такие строки автоматически:
```python
многострочная_строка = """Это многострочная
строка. Переносы строк
сохраняются."""
```
4) Сырые (raw) строки (`r"..."` или `R"..."`): Символы интерпретируются буквально, без обработки escape-последовательностей: `raw_string = r"C:\путь\к\файлу"`
5) Байтовые строки (`b"..."` или `B"..."`): Последовательности байтов (числа от 0 до 255), для бинарных данных: byte_string = b"\x00\x01\x02"

#### 2. Основные операции над строками:

1) Манипуляция с регистром:
    1. `str.lower()`: В нижний регистр.
    2. `str.upper()`: В верхний регистр.
    3. `str.capitalize()`: Только первую букву в верхний регистр.
    4. `str.title()`: Первую букву каждого слова в верхний регистр.
    5. `str.swapcase()`: Меняет регистр каждого символа.

2) Проверка наличия символов:
    1. `in`: Проверка наличия подстроки: "ell" in "hello" (True)
    2. str.startswith(prefix): Проверка на начало строки.
    3. str.endswith(suffix): Проверка на окончание строки.
    4. str.isalnum(): Только буквы и цифры.
    5. str.isalpha(): Только буквы.
    6. str.isdigit(): Только цифры.
    7. str.islower(): Только строчные буквы.
    8. str.isupper(): Только прописные буквы.
    9. str.isspace(): Только пробельные символы.
    10. str.find(substring): Возвращает индекс первого вхождения подстроки (-1, если не найдена).
    11. str.count(substring): Подсчитывает количество вхождений подстроки.
    12. Модуль re (регулярные выражения) для сложных шаблонов.

3) Очистка строки:
    1. str.strip(): Удаляет пробельные символы с начала и конца.
    2. str.lstrip(): Удаляет пробелы слева.
    3. str.rstrip(): Удаляет пробелы справа.

4) Разбиение и объединение строк:
    1. str.split(sep=None): Разделяет строку на список по разделителю (пробел по умолчанию).
    2. sep.join(iterable): Объединяет элементы итерируемого объекта в строку с разделителем sep.

#### 3. Работа с подстроками:
Срезы: `my_string[start:end:step]` — извлечение части строки.
`str.replace(old, new, count)`: Замена подстроки.

Пример:
```python
my_string = "  Hello, World!  "
print(my_string.strip().lower())  # hello, world!
print(my_string.split(","))       # ['  Hello', ' World!  ']
print(" ".join(["apple", "banana"])) # apple banana
print(my_string.find("World"))     # 8
print(my_string[7:12])              # World
```

---

## Билет 13. Словари. Понятие хешируемости и ограничения на ключи словаря. Упорядоченность словарей. Основные операции над словарями и методы словарей.

#### 1. Словарь
В Python словарь (тип dict) — это неупорядоченная (в Python 3.6 и выше — упорядоченная, но это важное уточнение, см. ниже) коллекция пар “ключ-значение”. Каждый ключ должен быть хешируемым, а значения могут быть любого типа.

#### 2. Хешируемость:
Хешируемость означает, что объект может быть преобразован в хеш-код — целое число, используемое для быстрого поиска значения по ключу в словаре. 

Для того, чтобы быть хешируемым, объект должен удовлетворять следующим условиям:
1) Неизменяемость: Хеш-код объекта должен оставаться неизменным на протяжении всего его существования. Изменяемые объекты (списки, словари) не могут быть ключами словаря.
2) Сравнение: Объект должен поддерживать операцию сравнения (`==` и `!=`) для определения равенства ключей.

#### 3. Ограничения на ключи словаря:
Ключами словаря могут быть только хешируемые объекты. Это означает, что следующие типы данных не могут быть ключами:list (списки), dict (словари),set (множества), другие изменяемые объекты

Ключами могут быть: int (целые числа), float (числа с плавающей точкой), str (строки), tuple (кортежи) — если все элементы кортежа также хешируемы,frozenset (неизменяемые множества)

#### 4. Упорядоченность словарей:
В Python 3.6 и более поздних версиях словари сохраняют порядок добавления ключей. Это означает, что итерация по ключам словаря будет происходить в том же порядке, в котором они были добавлены. В версиях Python до 3.6 порядок ключей не гарантировался. Однако, полагаться на это свойство в кроссплатформенном коде не рекомендуется, если это не критично.

#### 5. Основные операции и методы словарей:
Создание словаря:
```python 
my_dict = {'a': 1, 'b': 2, 'c': 3}
my_dict = dict(a=1, b=2, c=3)
my_dict = dict([('a', 1), ('b', 2), ('c', 3)])
```
Доступ к значению по ключу:
```python
value = my_dict['a']  # value будет равно 1
```
Если ключа нет, возникнет исключение `KeyError`. Для безопасного доступа:
```python
value = my_dict.get('d', 0)  # value будет равно 0, если ключа 'd' нет
``` 
Добавление или изменение значения:
```python
my_dict['d'] = 4
my_dict['a'] = 10  # Изменение существующего значения
```
Удаление значения:
```python
del my_dict['a']
value = my_dict.pop('b') # Удаляет и возвращает значение по ключу 'b'
```
Проверка наличия ключа:
```python
if 'c' in my_dict:
    print("Ключ 'c' существует")
```
Итерация по словарю:
```python
for key in my_dict:
    print(key, my_dict[key])

for key, value in my_dict.items():
    print(key, value)
```

#### 6. Основные методы:
1) `my_dict.keys()`: Возвращает представление ключей.
2) `my_dict.values()`: Возвращает представление значений.
3) `my_dict.items()`: Возвращает представление пар (ключ, значение).
4) `my_dict.clear()`: Очищает словарь.
5) `my_dict.copy()`: Создает копию словаря.
6) `len(my_dict)`: Возвращает количество пар ключ-значение.

---


## 14. Исключения. Механизм распространения исключений. try-except-else-finally блок. Ключевое слово raise, конструкция raise from. Мотивация и примеры использования.

#### 1. Исключения в Python
Исключения в Python — это механизм обработки ошибок и нестандартных ситуаций во время выполнения программы. Они позволяют отделить обработку ошибок от основного потока выполнения кода, делая программу более устойчивой и читаемой.

#### 2. Механизм распространения исключений:
Когда возникает исключение, выполнение текущей функции прерывается. Если исключение не обработано в этой функции (с помощью блока `try-except`), оно “распространяется” вверх по стеку вызовов — в вызывающую функцию. Этот процесс продолжается до тех пор, пока исключение не будет обработано или не достигнет вершины стека, что приводит к аварийному завершению программы и сообщению об ошибке.

#### 3. Блок try-except-else-finally:
Это основная конструкция в Python для обработки исключений:
```python
try:
    # Блок кода, который может вызвать исключение
    result = 10 / 0  # Деление на ноль вызовет ZeroDivisionError
except ZeroDivisionError:
    # Обработка исключения ZeroDivisionError
    print("Деление на ноль!")
except Exception as e:  # Обработка любых других исключений
    print(f"Произошла ошибка: {e}")
else:
    # Этот блок выполняется, если в блоке try исключений не возникло
    print(f"Результат: {result}")
finally:
    # Этот блок выполняется всегда, независимо от того, возникло исключение или нет
    print("Этот код выполнится в любом случае")
```
1) `try`: Блок кода, в котором может возникнуть исключение.
2) `except`: Один или несколько блоков обработки конкретных типов исключений.
3) `else`: Выполняется только если в блоке try исключений не возникло.
4) `finally`: Выполняется всегда, независимо от того, возникло исключение или нет. Часто используется для освобождения ресурсов (закрытие файлов, соединений с базой данных и т.д.).

#### 4. Ключевое слово raise:
Позволяет явно генерировать исключение:
```python
def check_age(age):
    if age < 0:
        raise ValueError("Возраст не может быть отрицательным")
    print(f"Возраст: {age}")

try:
    check_age(-5)
except ValueError as e:
    print(e)
```

#### 5. Конструкция raise from:
Позволяет связать новое исключение со старым, сохраняя информацию о цепочке исключений:
```python
try:
    with open("nonexistent_file.txt", "r") as f:
        contents = f.read()
except FileNotFoundError as e:
    raise IOError("Ошибка чтения файла") from e  # Новое исключение с информацией о старом
```
Это полезно для отладки и логирования, чтобы видеть первопричину ошибки.

#### 6.Мотивация и примеры использования:
1) Обработка ошибок ввода-вывода: Обработка ситуаций, когда файл не найден, нет доступа к сети и т.д.
2) Обработка ошибок в работе с базами данных: Обработка ошибок подключения, запросов и т.д.
3) Обработка ошибок валидации данных: Проверка корректности вводимых данных пользователем.
4) Управление потоком выполнения: Использование исключений для выхода из вложенных циклов или функций в случае ошибки.
5) Создание собственных исключений: Определение собственных типов исключений для более точной обработки ошибок в конкретном приложении.

## 15. Модули. Мотивация использования. Доступ к содержимому модуля. Конструкции import, from ... import ..., from ... import as ..., from ... import \*. Порядок поиска модулей.

#### 1. Модули
Модули в Python — это файлы, содержащие Python-код (функции, классы, переменные). Они позволяют организовывать код в логические блоки, повторно использовать код в разных программах и улучшать читаемость и структуру проекта.

#### 2. Мотивация использования:
1) Организация кода: Разбиение больших программ на более мелкие, управляемые модули повышает читаемость и упрощает отладку.
2) Повторное использование кода: Написанный однажды модуль можно использовать во многих проектах, избегая дублирования кода.
3) Управление зависимостями: Модули помогают управлять зависимостями проекта, четко определяя, какие библиотеки и компоненты используются.
4) Совместная работа: Разделение кода на модули упрощает совместную работу над проектом, позволяя разным разработчикам работать над отдельными частями кода.
5) Абстракция: Модули скрывают детали реализации, предоставляя пользователю простой интерфейс.

#### 3. Доступ к содержимому модуля:
Для использования функций, классов и переменных из модуля, необходимо импортировать его в программу. Существует несколько способов импорта:
1) import <module_name>: Импортирует весь модуль. Для доступа к его элементам используется полное имя: <module_name>.<element_name>.
```python
import math
result = math.sqrt(25)  # Используем функцию sqrt из модуля math
```
2) from <module_name> import <element_name>: Импортирует только указанные элементы из модуля. Можно импортировать несколько элементов через запятую.
```python
from math import sqrt, pi
result = sqrt(25)
circumference = 2 * pi * 5
```
3) `from <module_name> import <element_name> as <alias_name>` Импортирует элемент и дает ему другое имя (алиас). Полезно для сокращения длинных имен или избежания конфликтов имен.
```python
from math import sqrt as square_root
result = square_root(25)
```
4)` from __module_name__ import *`: Импортирует все элементы из модуля. Не рекомендуется для больших модулей, так как может привести к конфликтам имен и снижению читаемости кода.

#### 4. Порядок поиска модулей:
Когда Python импортирует модуль, он ищет его в следующих местах:
1) Текущий каталог: Сначала Python ищет модуль в текущем каталоге, из которого запущена программа.
2) Список стандартных путей: Это список каталогов, указанных в переменной среды PYTHONPATH (если она установлена) и в переменной sys.path. Сюда входят каталоги, где установлены стандартные библиотеки Python.
3) Пути, указанные в sys.path: Если модуль не найден в предыдущих местах, Python ищет его в каталогах, перечисленных в sys.path. Этот список можно изменить программно.

Пример:
```python
import os
import sys

print(sys.path)  # Выведет список путей поиска модулей

my_module = __import__("my_module") # Динамический импорт - импортирует модуль по имени, хранящемуся в переменной
result = my_module.my_function(5)
```
В этом примере мы сначала выводим список путей поиска, а затем динамически импортируем модуль my_module, предпологая, что он находится в одном из указанных путей и содержит функцию my_function. Обратите внимание на использование "__import__" для динамического импорта.

## 16. Исполняемые модули. Конструкция if \_\_name__ == «\_\_main__». Примеры и мотивация использования. Пакеты. Мотивация использования. 

#### 1. Исполняемые модули
В Python каждый файл .py является модулем. Если этот файл выполняется непосредственно (а не импортируется как модуль в другую программу), то значение переменной \_\_name__ будет равно "\_\_main__". Это позволяет условно выполнять определенный код только при прямом запуске файла:
```python
def my_function():
    print("Это функция из модуля")

if __name__ == "__main__":
    print("Этот код выполнится только при прямом запуске файла")
    my_function()
```

#### 2. Мотивация использования:
1) Тестирование: Блок if \_\_name__ == "\_\_main__": часто используется для написания тестового кода, который выполняется только при прямом запуске модуля, а не при импортировании его в другую программу.
2) Точка входа: Определяет точку входа в программу, когда она запускается как самостоятельное приложение.
3) Условное выполнение кода: Позволяет выполнять определенные участки кода только в определенных условиях.

Примеры:
```python
# my_module.py
def my_function(x):
  return x * 2

if __name__ == "__main__":
  result = my_function(5)
  print(f"Результат: {result}") #Выведет 10 если запустить my_module.py
```
В этом случае, my_function доступна для использования из других модулей, но тестовый код внутри `if __name__ == "__main__"`: выполнится только при запуске my_module.py напрямую.

#### 3. Пакеты:
Пакеты — это способ организации модулей в иерархические структуры. Они позволяют группировать родственные модули в одну директорию и управлять зависимостями между ними. Для создания пакета необходимо создать директорию, содержащую файл \_\_init__.py (может быть пустым). Это файл сигнализирует Python о том, что данная директория является пакетом.

##### mypackage/
##### ├── \_\_init__.py
##### ├── module1.py
##### └── module2.py

#### 4. Мотивация использования пакетов:
1) Структура больших проектов: Организация больших проектов в пакеты делает код более модульным и понятным.
2) Управление зависимостями: Пакеты облегчают управление зависимостями между модулями.
3) Пространство имен: Пакеты помогают избежать конфликтов имен между модулями.
4) Распространение кода: Пакеты – стандартный способ распространения библиотек и фреймворков Python.
Пример использования пакета:
```python
# mypackage/__init__.py  (может быть пустым)

# mypackage/module1.py
def function1():
    print("Функция из module1")

# mypackage/module2.py
def function2():
    print("Функция из module2")

# main.py
import mypackage.module1
import mypackage.module2

mypackage.module1.function1()
mypackage.module2.function2()
```
В этом примере *mypackage* является пакетом, содержащим два модуля. В *main.py* мы импортируем и используем функции из этих модулей.

---



# Функции 

## 1. Понятие функции в программировании и мотивация использования. 

#### 1. Функция в программировании
Функция — это блок кода, который выполняет определенную задачу и может быть вызван из других частей программы. Она представляет собой абстракцию, которая позволяет разбить сложную задачу на более мелкие, управляемые подзадачи.

#### 2.Мотивация использования функций:
1) Модульность: Разбиение программы на функции делает код более модульным, организованным и понятным. Каждая функция отвечает за свою конкретную задачу, что упрощает понимание и отладку кода.
2) Повторное использование кода: Функции позволяют избежать дублирования кода. Если какая-то задача выполняется в нескольких местах программы, ее можно реализовать в виде функции и вызывать эту функцию всякий раз, когда это необходимо. Это улучшает читаемость, уменьшает размер кода и снижает вероятность ошибок.
3) Абстракция: Функции скрывают детали реализации. Пользователь функции не обязан знать, как она работает внутри, ему достаточно знать, какие входные данные она принимает и какой результат возвращает. Это упрощает работу с кодом и делает его более гибким.
4) Упрощение отладки: Разделение программы на функции упрощает отладку. Если возникает ошибка, легче локализовать ее в конкретной функции, чем в большом, неструктурированном блоке кода.
5) Тестирование: Функции легко тестировать независимо друг от друга. Это позволяет убедиться в корректной работе каждой функции перед интеграцией в более крупную систему.
6) Параметризация: Функции могут принимать параметры (аргументы), что делает их более универсальными и гибкими. Одна и та же функция может выполнять разные задачи в зависимости от переданных ей параметров.
7) Разделение ответственности: Каждая функция отвечает за выполнение определенной задачи, что повышает надежность и возможность поддержки кода.

## 2. Некоторые встроенные функции: min(), max(), sum(), sorted(), print(), input(). Примеры использования.

#### 1. min() и max():
Эти функции возвращают соответственно минимальное и максимальное значения из итерируемого объекта (например, список, кортеж) или из нескольких аргументов.
```python
numbers = [3, 1, 4, 1, 5, 9, 2, 6]
minimum = min(numbers)  # minimum будет 1
maximum = max(numbers)  # maximum будет 9

print(f"Минимальное значение: {minimum}")
print(f"Максимальное значение: {maximum}")

min_val = min(2, 5, 1, 9, 3) #min_val будет 1
max_val = max(2, 5, 1, 9, 3) #max_val будет 9
print(f"Минимальное значение: {min_val}")
print(f"Максимальное значение: {max_val}")
```

#### 2. sum():
Эта функция возвращает сумму всех элементов числового итерируемого объекта.
```python
numbers = [1, 2, 3, 4, 5]
total = sum(numbers)  # total будет 15
print(f"Сумма: {total}")
```

#### 3. sorted():
Эта функция возвращает новый отсортированный список, содержащий все элементы из итерируемого объекта. Оригинальный список остается неизменным.
```python
numbers = [3, 1, 4, 1, 5, 9, 2, 6]
sorted_numbers = sorted(numbers)  # sorted_numbers будет [1, 1, 2, 3, 4, 5, 6, 9]
print(f"Отсортированный список: {sorted_numbers}")
print(f"Оригинальный список: {numbers}") #Оригинальный список остался неизменным

words = ["banana", "apple", "cherry"]
sorted_words = sorted(words) # sorted_words будет ['apple', 'banana', 'cherry']
print(f"Отсортированный список слов: {sorted_words}")
```
#### 4. print():
Эта функция выводит значения на консоль. Она может принимать несколько аргументов, разделенных запятыми.
```python
name = "Alice"
age = 30
print("Имя:", name, ", возраст:", age)  # Вывод: Имя: Alice , возраст: 30
print(f"Имя: {name}, возраст: {age}") # Вывод: Имя: Alice, возраст: 30 - форматированная строка
```

#### 5. input():
Эта функция считывает строку с консоли.
```python
name = input("Введите ваше имя: ")
print(f"Привет, {name}!")
```

## 3. Пользовательские функции: определение пользовательских функций. Символические таблицы. Инструкция return и возвращаемое значение. 

#### 1. Определение пользовательских функций:
В Python пользовательские функции определяются с помощью ключевого слова def, за которым следует имя функции, список параметров в скобках и двоеточие. Тело функции, то есть код, который она выполняет, отступается на четыре пробела (или табуляцию) относительно начала определения функции.
```python
def my_function(param1, param2):
    """Docstring: описание функции."""
    # Тело функции
    result = param1 + param2
    return result

# Пример вызова функции
sum_result = my_function(5, 3)
print(sum_result)  # Вывод: 8
```
- `def`: Ключевое слово, обозначающее определение функции.
- `my_function`: Имя функции (идентификатор). Должно следовать правилам именования переменных в Python.
- `(param1, param2)`: Список параметров (аргументов), которые принимает функция. Они могут быть именованными или позиционными.
- `"""Docstring: описание функции."""`: Строка документации (docstring). Она описывает, что делает функция и как её использовать. Это важная часть написания качественного кода.
- `result = param1 + param2`: Тело функции, содержащее код, который она выполняет.
- `return result`: Инструкция return возвращает значение из функции. Если инструкция return отсутствует, функция возвращает None.

#### 2. Символические таблицы (scope):
Символическая таблица — это структура данных, используемая интерпретатором Python для отслеживания имен переменных и их значений. Каждая функция имеет свою собственную локальную символическую таблицу. Если переменная не найдена в локальной таблице, Python ищет её в глобальной таблице и затем в таблице встроенных функций. Это называется областью видимости (scope) переменных.
```python
global_var = 10

def my_function():
    local_var = 5
    print(global_var)  # Доступ к глобальной переменной
    print(local_var)  # Доступ к локальной переменной

my_function()
# print(local_var)  # Ошибка: local_var не определена в глобальной области видимости
```

#### 3. Инструкция return и возвращаемое значение:
Инструкция return завершает выполнение функции и возвращает значение. Возвращаемое значение может быть любого типа данных: число, строка, список, словарь, объект класса и т.д. Если функция не содержит инструкции return, она неявно возвращает значение None.
```python
def no_return_function():
  print("Функция без return")

def return_int():
  return 10

def return_string():
  return "Hello"

print(no_return_function()) # Вывод: None
print(return_int())       # Вывод: 10
print(return_string())    # Вывод: Hello
```

## 4. Передача аргументов в функции. Изменение объектов изменяемых типов данных в теле функции.

#### 1. Передача аргументов в функции. 
Python аргументы передаются в функции по ссылке (по значению для неизменяемых типов). Это означает, что переменная внутри функции ссылается на тот же объект, что и переменная, переданная в качестве аргумента.

1) Неизменяемые типы:
Для неизменяемых типов данных (int, float, str, tuple, frozenset), изменение переменной внутри функции создает новый объект, а исходный объект остается неизменным вне функции.
```python
def modify_immutable(x):
    x = x + 1  # Создается новый объект
    return x

a = 5
b = modify_immutable(a)
print(a)  # Вывод: 5 (исходный объект не изменился)
print(b)  # Вывод: 6 (новый объект)
```

2) Изменяемые типы:
Для изменяемых типов данных (list, dict, set), изменение объекта внутри функции изменяет сам объект, на который ссылаются все переменные, включая переменную, переданную в функцию.
```python
def modify_mutable(my_list):
    my_list.append(4)  # Изменяем существующий объект

my_list = [1, 2, 3]
modify_mutable(my_list)
print(my_list)  # Вывод: [1, 2, 3, 4] (исходный список изменился)
```
В этом примере функция modify_mutable добавляет элемент в список, переданный ей в качестве аргумента. Этот список изменяется на месте, и эти изменения видны вне функции.

#### 2. Как избежать нежелательных изменений:
Если вы не хотите, чтобы функция изменяла переданный ей изменяемый объект, можно создать копию объекта перед его обработкой внутри функции:
```python
import copy

def modify_mutable_safe(my_list):
    new_list = copy.deepcopy(my_list) #Создаем глубокую копию списка
    new_list.append(4)
    return new_list

my_list = [1, 2, 3]
new_list = modify_mutable_safe(my_list)
print(my_list)  # Вывод: [1, 2, 3] (оригинал не изменился)
print(new_list)  # Вывод: [1, 2, 3, 4] (новая копия)
```
Здесь мы используем copy.deepcopy() для создания полной копии списка. Изменения в копии не влияют на исходный список. Для более простых объектов, можно использовать copy.copy(), но для вложенных структур лучше использовать copy.deepcopy(), чтобы избежать неожиданного изменения оригинала.


## 5. Параметры по умолчанию. Время вычисления параметров по умолчанию.  Ошибка  использования  изменяемых  объектов  в качестве  параметров  по  умолчанию.  Правильные  подходы  для использования  изменяемых  объектов  в  качестве  параметров  по умолчанию. 

#### 1. Параметры по умолчанию:
В Python можно задавать значения по умолчанию для параметров функций. Если при вызове функции значение параметра не указано, используется значение по умолчанию.
```python
def greet(name, greeting="Hello"):
    print(f"{greeting}, {name}!")

greet("Alice")  # Выведет: Hello, Alice!
greet("Bob", "Hi")  # Выведет: Hi, Bob!
```

#### 2. Время вычисления параметров по умолчанию:
Значения параметров по умолчанию вычисляются только один раз, когда функция определяется, а не каждый раз, когда функция вызывается. Это важно учитывать при использовании изменяемых объектов (списки, словари) в качестве параметров по умолчанию.

#### 3. Ошибка использования изменяемых объектов в качестве параметров по умолчанию:
Если в качестве параметра по умолчанию используется изменяемый объект, то изменения, внесенные в этот объект внутри функции, сохраняются для последующих вызовов функции.
```python
def add_to_list(x, my_list=[]):
    my_list.append(x)
    print(my_list)

add_to_list(1)  # Выведет: [1]
add_to_list(2)  # Выведет: [1, 2]  <- Ошибка!  Список должен был быть пустым
add_to_list(3)  # Выведет: [1, 2, 3] <- Ошибка! Список не пустой
```
В этом примере, список my_list создается только один раз при определении функции. Каждый последующий вызов add_to_list использует тот же самый список, что приводит к непредвиденному накоплению элементов.

#### 4. Правильные подходы для использования изменяемых объектов в качестве параметров по умолчанию:

Чтобы избежать этой ошибки, следует использовать значение None в качестве параметра по умолчанию и создавать новый изменяемый объект внутри функции, если значение None передается:
```python
def add_to_list(x, my_list=None):
    if my_list is None:
        my_list = []
    my_list.append(x)
    print(my_list)

add_to_list(1)  # Выведет: [1]
add_to_list(2)  # Выведет: [2]
add_to_list(3, [10, 20])  # Выведет: [10, 20, 3]
```
Теперь каждый вызов функции создает новый пустой список, если параметр my_list не указан. Это гарантирует корректное поведение функции.

##### Альтернативный подход (менее распространенный):
Можно использовать my_list = list() вместо my_list = []. Это создает новый пустой список, но в отличии от первого примера, не создает “необходимость” в дополнительном условном выражении.

## 6. Именованные и позиционные аргументы. Строго именованные и строго позиционные аргументы. Мотивация использования. 

#### 1. Именнованные и позиционные аргументы
При вызове функций в Python можно передавать аргументы двумя способами: позиционно и именованно. Понимание разницы между ними, а также использование строго именованных и строго позиционных аргументов, важно для написания чистого и читаемого кода.

1. **Позиционные аргументы**:
Позиционные аргументы передаются в том порядке, в котором они определены в сигнатуре функции. Их порядок важен, и при вызове функции необходимо передать аргументы в правильном порядке.
```python
def my_function(a, b, c):
    print(f"a = {a}, b = {b}, c = {c}")

my_function(1, 2, 3)  # a = 1, b = 2, c = 3
```

2. Именованные аргументы:
Именованные аргументы передаются с указанием имени параметра. Порядок именованных аргументов не важен.
```python
my_function(c=3, a=1, b=2)  # a = 1, b = 2, c = 3
```

Комбинация позиционных и именованных аргументов:
Можно комбинировать позиционные и именованные аргументы в одном вызове функции. Однако, именованные аргументы должны идти после позиционных аргументов.
```python
my_function(1, b=2, c=3)  # a = 1, b = 2, c = 3  - корректный вызов
# my_function(a=1, 2, 3) - некорректный вызов
```
#### 2. Строго именованные и строго позиционные аргументы (Python 3.8+):
Python 3.8 ввел возможность использовать / и * в сигнатуре функции для разделения позиционных и именованных аргументов.
1) /: Все аргументы до / являются строго позиционными. Их нельзя передавать именованно.
2) \*: Все аргументы после * являются строго именованными. Их нельзя передавать позиционно.
```python
def my_function(a, b, /, c, d, *):
    print(f"a = {a}, b = {b}, c = {c}, d = {d}")

my_function(1, 2, c=3, d=4)  # корректный вызов
#my_function(a=1, b=2, c=3, d=4) - некорректный вызов (a и b строго позиционные)
#my_function(1, 2, 3, d=4) - некорректный вызов (d строго именованный)
```

#### 3. Мотивация использования:
1) Читаемость: Именованные аргументы делают код более читаемым, особенно когда функция имеет много параметров. Они явно указывают, какое значение соответствует какому параметру.
2) Упрощение: Именованные аргументы позволяют пропускать некоторые аргументы, используя значения по умолчанию.
3) Предотвращение ошибок: Строго позиционные и строго именованные аргументы помогают избежать ошибок, связанных с неправильным порядком аргументов. Они обеспечивают более строгую проверку типов и аргументов при вызове функции.
4) Более надежный и предсказуемый код: Явное указание позиционных и именованных параметров делает функцию более понятной и упрощает отладку.


## 7. Синтаксис \*args, \*\*kwargs. Мотивация и примеры использования. 

#### 1. \*args, \*\*kwargs
В Python \*args и \*\*kwargs — это соглашения по именованию, используемые для передачи переменного количества позиционных и именованных аргументов в функцию соответственно. Они очень полезны при создании гибких функций, способных обрабатывать различные количества входных данных.

1) \*args (позиционные аргументы):
\*args позволяет функции принимать любое количество позиционных аргументов. Внутри функции args будет кортежем этих аргументов.
```python
def my_sum(*args):
    total = 0
    for num in args:
        total += num
    return total

print(my_sum(1, 2, 3))  # 6
print(my_sum(10, 20, 30, 40))  # 100
print(my_sum())  # 0
```

2) \*\*kwargs (именованные аргументы):
\*\*kwargs позволяет функции принимать любое количество именованных аргументов. Внутри функции kwargs будет словарем, где ключи — это имена аргументов, а значения — их значения.
```python
def print_kwargs(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_kwargs(name="Alice", age=30, city="New York")
# name: Alice
# age: 30
# city: New York
``` 

Комбинация *args и **kwargs:
Можно использовать и *args, и **kwargs в одной функции. При этом *args должен идти перед **kwargs.
```python
def my_function(*args, **kwargs):
    print("Позиционные аргументы:", args)
    print("Именованные аргументы:", kwargs)

my_function(1, 2, 3, name="Bob", age=25)
# Позиционные аргументы: (1, 2, 3)
# Именованные аргументы: {'name': 'Bob', 'age': 25}
```

#### 2. Мотивация использования:
1) Гибкость: \*args и \*\*kwargs позволяют создавать функции, которые могут обрабатывать неопределенное количество аргументов, что делает их более универсальными.
2) Расширяемость: Функции, использующие \*args и \*\*kwargs, легко расширять, добавляя новые параметры без изменения их сигнатуры.
3) Передача аргументов другим функциям: \*args и \*\*kwargs позволяют удобно передавать аргументы из одной функции в другую.

#### 3. Примеры использования:
1) Функции-обертки: \*args и \*\*kwargs часто используются для создания функций-оберток, которые добавляют функциональность к существующим функциям.
2) Обработка данных из различных источников: \*args и \*\*kwargs позволяют объединять данные из различных источников в одном месте.
3) Создание универсальных функций: \*args и \*\*kwargs помогают создать функции, которые могут работать с различными типами и количеством входных данных.

## 8. Метаинформация о функциях: \_\_name__, docstring и аннотации типов. Мотивация использования. 

#### 1. Метаинформация о функциях
Метаинформация о функциях в Python — это данные, описывающие саму функцию, а не ее поведение во время выполнения. К ключевым элементам метаинформации относятся:

1. \_\_name__:
Атрибут \_\_name__ содержит имя функции. Он полезен для:
1) Идентификации функции: Можно использовать для проверки имени функции в отладочном коде или в системах тестирования.
2) Динамического вызова функций: Можно динамически вызывать функции по имени, хранящемуся в переменной.
```python
def my_function():
    print("Hello from my_function")

print(my_function.__name__)  # Выведет: my_function

function_name = "my_function"
globals()[function_name]() # Вызовет my_function()
```

2. Docstring (строка документации):
Docstring — это строка, которая описывает назначение функции, ее параметры и возвращаемое значение. Она пишется в тройных кавычках ("""Docstring здесь""") непосредственно после определения функции. Docstring используется для:
1) Документации: Она служит основным источником информации о функции для других программистов (и для самого автора через некоторое время).
2) Автоматической генерации документации: Инструменты, такие как Sphinx, могут использовать docstring для создания профессиональной документации к коду.
3) Интерактивная помощь: В интерпретаторе Python можно использовать `help()` или ? для просмотра docstring функции.
```python
def my_function(a, b):
    """Эта функция суммирует два числа.

    Args:
        a: Первое число.
        b: Второе число.

    Returns:
        Сумма двух чисел.
    """
    return a + b

help(my_function) # выведет docstring в консоль
```

3. Аннотации типов (Type Hints):
Аннотации типов (введены в Python 3.5) позволяют указывать типы параметров и возвращаемого значения функции. Они не влияют на выполнение кода, но служат для:
1) Статического анализа: Инструменты статического анализа кода (например, MyPy) могут использовать аннотации типов для проверки корректности типов данных.
2) Автоматической генерации документации: Аннотации типов могут быть включены в автоматически генерируемую документацию.
3) Повышения читаемости: Аннотации типов делают код более понятным, указывая ожидаемые типы данных.
```py
def my_function(a: int, b: int) -> int:
    return a + b

# MyPy (или другой статический анализатор) сможет проверить, соответствуют ли типы
```

#### 2. Мотивация использования метаинформации:
1) Читаемость и сопровождение: Метаинформация делает код более понятным и легким для сопровождения, особенно в больших проектах.
2) Проверка ошибок: Аннотации типов помогают предотвращать ошибки, связанные с несоответствием типов данных.
3) Автоматизация: Метаинформация может использоваться для автоматической генерации документации и других задач.
4) Лучшее понимание кода: Документация, аннотации, имя функции – все это помогает лучше понять назначение кода и упрощает его поддержку.

## 9. Функции,  как  объекты  высшего  порядка:  создание  функций  во время  исполнений,  присвоение  функции  переменным, использование функций в качестве аргументов и возвращаемых значений других функций. Примеры. 

#### 1. Функции - объект высшего порядка
Функции в Python — это объекты первого класса. Это означает, что функции можно использовать так же, как и другие объекты: их можно создавать во время выполнения, присваивать переменным, передавать в качестве аргументов и возвращать как значения из других функций. Это делает Python языком с функциями высшего порядка.

1. Создание функций во время исполнения:
Функции можно создавать с помощью оператора def или с помощью lambda-выражений (анонимных функций).
```python
def create_adder(x):
    def adder(y):
        return x + y
    return adder

add_5 = create_adder(5)
print(add_5(3))  # Выведет 8

add_10 = create_adder(10)
print(add_10(7)) # Выведет 17

# Пример с lambda:
add_lambda = lambda x, y: x + y
print(add_lambda(5, 3)) # Выведет 8
```

2. Присвоение функций переменным:
Функции можно присваивать переменным. Это позволяет использовать функцию под разными именами или передавать ее в качестве аргумента.
```py
def my_function(x):
    return x * 2

my_alias = my_function
print(my_alias(5))  # Выведет 10
```

3. Использование функций в качестве аргументов других функций:
Функции могут принимать другие функции в качестве аргументов. Это позволяет создавать высокоуровневые абстракции и писать более гибкий код (например, Callback-функции).
```py
def apply_function(func, x):
    return func(x)

def square(x):
    return x * x

def cube(x):
    return x * x * x

print(apply_function(square, 5))  # Выведет 25
print(apply_function(cube, 5))   # Выведет 125
```
4. Использование функций в качестве возвращаемых значений других функций:
Функции могут возвращать другие функции в качестве результата. Это позволяет создавать функции-фабрики (function factories), которые генерируют новые функции на основе каких-то параметров.
```py
def create_multiplier(factor):
    def multiplier(x):
        return x * factor
    return multiplier

double = create_multiplier(2)
triple = create_multiplier(3)
print(double(5))  # Выведет 10
print(triple(5))  # Выведет 15
```

#### 2. Примеры использования:
1) Функции-декораторы: Декораторы — это функции, которые модифицируют другие функции. Они используют функции высшего порядка.
2) Обработка данных: Функции высшего порядка позволяют применять различные функции обработки к данным (например, сортировку, фильтрацию).
3) Асинхронное программирование: В асинхронном программировании часто используются функции высшего порядка для обработки колбэков и промисов.
4) Создание DSL (Domain Specific Languages): Функции высшего порядка могут использоваться для построения специальных языков программирования для конкретной предметной области.

## 10. Ключевые  слова  global и  nonlocal. Замыкания.  Мотивация  и примеры использования. 

#### 1. Ключевые слова global и nonlocal
Ключевые слова global и nonlocal используются для управления областью видимости переменных в Python. Они важны для понимания замыканий.

1. Ключевое слово global:
global используется для объявления, что переменная, используемая внутри функции, относится к глобальной переменной, а не к локальной. Без global, присвоение значения переменной внутри функции создаст новую локальную переменную.
```python
global_var = 10

def modify_global():
    global global_var  # Объявляем, что используем глобальную переменную
    global_var = 20

modify_global()
print(global_var)  # Выведет 20
```

2. Ключевое слово nonlocal:
nonlocal используется для объявления, что переменная, используемая внутри вложенной функции, относится к переменной из ближайшей внешней, но не глобальной, области видимости.
```python
def outer_function():
    outer_var = 10

    def inner_function():
        nonlocal outer_var  # Объявляем, что используем outer_var из внешней функции
        outer_var = 20

    inner_function()
    print(outer_var)  # Выведет 20

outer_function()
```

3. Замыкания (Closures):
Замыкание — это функция, которая помнит и имеет доступ к переменным из своей окружающей (лексической) области видимости, даже после того, как окружающая функция завершила свое выполнение. nonlocal играет ключевую роль в замыканиях.
```py
def create_multiplier(factor):
    def multiplier(x):
        return x * factor  # factor – это переменная из лексической области видимости
    return multiplier

double = create_multiplier(2)
print(double(5))  # Выведет 10
# Даже после того, как create_multiplier завершила работу, multiplier помнит factor
```
В этом примере multiplier — замыкание. Она «замыкает» переменную factor из своей лексической области видимости.

#### 2. Мотивация и примеры использования:
1) Создание функций-фабрик: Замыкания позволяют создавать функции, которые сохраняют состояние между вызовами.
2) Сокрытие данных: Замыкания могут использоваться для сокрытия данных внутри функции и предоставления доступа к ним только через определенные методы.
3) Обработка событий: В событийно-ориентированном программировании замыкания используются для передачи контекста обработчикам событий.
4) Улучшение читаемости и организации кода: Замыкания позволяют организовать код в более модульные и понятные части.

Пример с замыканием и nonlocal:
```py
def counter():
    count = 0
    def increment():
        nonlocal count
        count += 1
        return count
    return increment

my_counter = counter()
print(my_counter())  # 1
print(my_counter())  # 2
print(my_counter())  # 3
```
В этом примере increment — замыкание, которое имеет доступ к переменной count из counter, даже после того, как counter завершила свое выполнение.

## 11. Декораторы.  Мотивация  и  примеры  использования.  Декоратор wraps. Мотивация использования. Параметрические декораторы. Примеры и мотивация использования.
#### 1. Декораторы
Декораторы — это способ модифицировать поведение функции или метода без изменения их исходного кода. Они используют функции высшего порядка и замыкания.

Базовый декоратор:
```py
def my_decorator(func):
    def wrapper():
        print("Перед вызовом функции")
        func()
        print("После вызова функции")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
# Вывод:
# Перед вызовом функции
# Hello!
# После вызова функции
```
Здесь my_decorator — декоратор. Он принимает функцию say_hello в качестве аргумента, создает обертку (wrapper), которая выполняет дополнительный код до и после вызова исходной функции, и возвращает обертку. @my_decorator — синтаксический сахар, эквивалентный say_hello = my_decorator(say_hello).

#### 2. Мотивация использования декораторов:
1) Улучшение читаемости: Декораторы позволяют отделять дополнительную логику от основной функциональности функции, что делает код более чистым и понятным.
2) Избегание дублирования кода: Декораторы позволяют избежать повторного написания одинакового кода для разных функций.
3) Расширение функциональности: Декораторы позволяют легко добавлять новую функциональность к существующим функциям без изменения их исходного кода.

#### 3. Декоратор wraps:
Декоратор wraps из модуля functools используется для сохранения метаинформации (имя функции, docstring и т.д.) исходной функции после применения декоратора. Без wraps метаинформация будет относиться к функции-обертке.
```py
import functools

def my_decorator(func):
    @functools.wraps(func)
    def wrapper():
        print("Перед вызовом функции")
        func()
        print("После вызова функции")
    return wrapper

@my_decorator
def say_hello():
    """Функция, которая говорит 'Hello!'"""
    print("Hello!")

help(say_hello) # Теперь docstring будет корректным
```
#### 4. Мотивация использования wraps:
wraps улучшает читаемость и отладку кода, поскольку сохраняет исходную информацию о декорируемой функции.

#### 5. Параметрические декораторы:
Параметрические декораторы — это декораторы, которые принимают аргументы.
```py
def repeat(num_times):
    def decorator_repeat(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(num_times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator_repeat

@repeat(num_times=3)
def greet(name):
    print(f"Hello, {name}!")

greet("World")
# Вывод:
# Hello, World!
# Hello, World!
# Hello, World!
```
Здесь repeat — параметрический декоратор, который принимает num_times в качестве аргумента. Он возвращает другой декоратор (decorator_repeat), который затем декорирует функцию greet.

#### 6.Мотивация использования параметрических декораторов:
Параметрические декораторы позволяют создавать более гибкие и настраиваемые декораторы, которые могут изменять поведение функции в зависимости от переданных параметров. 

## 12. Анонимные  функции.  Мотивация  и  примеры  использования. Примеры  замыкания  анонимных  функций  на  локальный контекст.
#### 1. Анонимные функции
Анонимные функции, также известные как лямбда-функции, — это небольшие, одновыразительные функции, которые не имеют имени. Они определяются с помощью ключевого слова lambda.

Синтаксис:
```py
lambda arguments: expression
```
arguments: Список аргументов, разделенных запятыми.
expression: Выражение, которое вычисляется и возвращается функцией. Лямбда-функция может содержать только одно выражение.
Примеры:
```py
add = lambda x, y: x + y
print(add(5, 3))  # Выведет 8

square = lambda x: x * x
print(square(4))  # Выведет 16

even = lambda x: x % 2 == 0
print(even(10))  # True
print(even(7))  # False
```

#### 2. Мотивация использования анонимных функций:
1) Краткость: Лямбда-функции идеальны для коротких, простых функций, которые не требуют полного определения с помощью def.
2) Функции высшего порядка: Лямбда-функции часто используются в качестве аргументов для функций высшего порядка (например, map, filter, sorted).
3) Одноразовые функции: Если функция нужна только один раз, использование лямбда-выражения может упростить код и сделать его более читабельным, чем создание полноценной функции.
4) Примеры замыкания анонимных функций на локальный контекст:

#### 3. Замыкания с анонимными функциями
Замыкания с лямбда-функциями работают так же, как и с обычными функциями:
```py
def create_adder(x):
    return lambda y: x + y

add_5 = create_adder(5)
print(add_5(3))  # Выведет 8

add_10 = create_adder(10)
print(add_10(7)) # Выведет 17
```
Здесь create_adder возвращает лямбда-функцию, которая «замыкает» переменную x из своей лексической области видимости.

Более сложный пример с несколькими переменными:
```py
def make_multiplier(a, b):
  return lambda x: a*x + b

multiplier = make_multiplier(2, 3) # a=2, b=3
print(multiplier(5)) # (2*5) + 3 = 13
print(multiplier(10))# (2*10) + 3 = 23
```
В этом примере лямбда-функция lambda x: a*x + b замыкает переменные a и b из внешней функции make_multiplier.

##### Когда использовать, а когда нет:
Лямбда-функции полезны для коротких, простых операций. Для более сложных функций, требующих множества строк кода или многократного использования, лучше использовать обычные функции, определённые с помощью def. Чрезмерное использование лямбда-функций может снизить читаемость кода.


# Объектно-ориентированное программирование

## 1. Классы. Объект класса. Определение пользовательского класса. Объект класса как объект высшего порядка. Атрибуты класса.

#### 1. Классы

Класс — это пользовательский тип данных, позволяющий создавать экземпляры, которые могут иметь собственные свойства (состояние) и методы.

Это очень удобный способ хранения данных и ограничения круга возможных операций, применимых к этим данным, поэтому они могут оказаться весьма полезными при решении ряда задач.

Классы — это основные строительные блоки объектно-ориентированного программирования.

#### 2. Объект класса

**ВАЖНО!** Объект класса - это **НЕ** то же самое, что и *экземпляр класса*. О классе можно думать, как о некотором инструменте, содержащем описание объектов, которые могут считаться экземплярами данного класса, и позволяющем создавать эти экземпляры.

#### 3. Определение пользовательского класса

Простейшее определение класса имеет следующий вид:

```Python
class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
```

В теле класса (на месте ```<statement-i>```) могут быть написаны любые синтаксически корректные конструкции, но обычно там объявляются (и иногда определяются) атрибуты класса.

#### 4. Объект класса как объект высшего порядка

Объект класса (см. пункт 2) является полноправным объектом. Это означает, что он может быть использован в качестве аргумента функции, в качестве значения переменной, в качестве элемента списка и т.п.. Например:

```Python
class MyClass:
    """simple example class"""

    pass

def foo(a):
    pass

# a теперь ссылается на объект класса
a = MyClass

# всё это - валидные операции:
foo(a)
l = [a]
print(a)
```

#### 5. Атрибуты класса

Атрибуты класса — это поля, ответственные за хранение некоторых данных. Атрибуты класса могут быть как статическими, так и динамическими.

В роли атрибута может выступать любой объект (методы класса это тоже атрибуты класса), однако их можно разделить на две категории:

* дескрипторы - объекты, которые определяют специальный метод ```__get__```; если дескриптор также определяет специальный метод ```__set__```, то такой дескриптор называется переопределяющим дескриптором. Методы класса являются дескрипторами.

* все остальные объекты, которые не определяют метод ```__get__```.

Атрибуты можно определять динамически.

Пример:

```Python
class a:
    # атрибуты класса
    attr1: int = 1
    attr2: int = 2
    attr3: float = attr1 / attr2


def foo():
    print("boo")


b = a()
b.f = foo   # динамически добавляем атрибут экземпляра
b.f()       # выводит "boo"
```

Атрибуты класса образуют пространство имен, которое существует на протяжении всей жизни класса, т.е. на протяжении времени выполнения программы, в которой данный класс используется. Пространство имен класса сохраняется в специальном атрибуте ```__dict__```.

## 2. Экземпляры классов. Методы экземпляра. Специальный метод ```__init__```. Смысл аргумента ```self```. Статические методы.

#### 1. Экземпляры классов

Экземпляр класса - конкретная реализация класса, которая хранит конкретные данные. Экземпляр класса - это объект, тип данных которого равен данному классу. Создание экземпляров класса напоминает вызов функции и выглядит следуюшим образом:

```Python
class a:
    pass

b = a()
```

*Экземпляр класса* и *объект класса* - это разные понятия, однако тип данных *экземпляра класса* есть *объект класса*. Проще говоря:

```Python
isinstance(b, a) # True
```

#### 2. Методы экземпляра

Экземпляр класса имеет доступ к методам своего класса, а может динамически обретать методы, которые будут доступны только для данного экземпляра класса.

#### 3. Специальный метод ```__init__```

Для гибкой настройки экземпляра класса в момент создания в Python существует специальный метод ```__init__```. Он вызывается при создании экземпляра класса.

Типичные конструкторы осуществляют операции привязки атрибутов экземпляра к переданным значением. Важно отметить, что конструктор связывает с переданными значениями именно атрибуты экземпляра, поскольку каждый экземпляр создает свое простраство имен, в котором и хранятся значения атрибутов данного конкретного экземпляра.

Нередка ситуация, когда в конструкторе происходит что-то более сложное простой привязки атрибутов. Но если конструктор полностью состоит из данной привязки, вы можете с лекостью сократить количество однотипного кода, используя декоратор из библиотеки ```dataclasses```:

```Python
from dataclasses import dataclass


@dataclass
class Point2D:
    abscissa: float = 0
    ordinate: float = 0
```

#### 4. Смысл аргумента ```self```

Все функции, определяемые в теле класса (в том числе динамически, см. билет 1 ООП), должны обязательно иметь первый аргумент, который будет передан в функцию неявно при ее вызове. В качестве этого аргумента в функцию будет передан экземпляр класса, с которым связана данная функция. Конвенционально данный аргумент называется ```self```. Интерпретатору все равно на именование данного аргумента, и вы *можете* называть его как хотите, однако подобный стиль **крайне** нерекомендован.

#### 5. Статические методы

Для обращения к атрибутам класса вне данного класса необходимо указать имя класса и через точку указать имя атрибута, к которому вы хотите обратиться.

Вызов методов класса без создания экземпляра класса невозможен. Попытка совершить это вызовет ошибку. Однако вы можете создать статический метод, который не будет привязан к экземпляру класса и не будет иметь доступа к атрибутам класса. Для этого необходимо использовать декоратор ```@staticmethod```:

```Python
class a:
    @staticmethod
    def foo():
        pass

class b:
    def foo():
        pass

a.foo() # вызов статического метода, всё хорошо
b.foo() # ошибка(
```

## 3. Атрибуты классов и атрибуты экземпляров. Порядок поиска атрибутов. Динамичное добавление атрибутов.

#### 1. Атрибуты классов и атрибуты экземпляров

После создания экземпляра класса, возможно обращаться к его атрибутам таким же образом, как это происходило с атрибутами классов, только на этот раз, имя класса заменятеся на имя экземпляра:

```Python
class a:
    x = 0

b = a()
print(b.x) # 0
```

Можно вызывать методы классов у экземпляров, причем, как статичные, так и обычные:

``` Python
class a:
    def foo():
        pass

b = a()
b.foo()
```

Также, как и с классами, можно добавлять атрибуты экземпляра динамически.

#### 2. Порядок поиска атрибутов

Каждый экземпляр класса обладает собственным пространством имен, которое не имеет никакого влияния на исходный класс.
В каждом экземпляре класса храниться информация о том классе, экземпляром которого он является.

Если в экземпляре класса нет атрибута, то Python будет искать его в исходном классе. Если в исходном классе нет атрибута, то Python будет искать его в родительском классе, если есть, и так далее. Если в родительских классах нет атрибута, то Python будет искать его в модуле, в котором находится исходный класс, и, наконец, в глобальном пространстве имен. Если атрибут не найден ни в одном из этих мест, то Python будет выбрасывать ошибку.

#### 3. Динамичное добавление атрибутов

Атрибуты можно добавлять в ходе выполнения программы.

```Python
class a:
    pass

def foo():
    pass

def boo(*args, **kwargs):
    pass

b = a()

b.f = foo   # добавляем атрибут
b.f()       # будет вызвана функция foo
a.f()       # Ошибка: на исходный класс не распространяется изменение экземпляра

a.g = boo   # важно учетсть, что во все методы
            # класса будет неявно передаваться self

b.g()       # будет вызвана функция boo
```

## 4. Модуль стандартной библиотеки dataclasses. Декоратор dataclass и мотивация использования.

#### 1. Модуль стандартной библиотеки dataclasses

Этот модуль предоставляет декоратор и функции для автоматического добавления сгенерированных специальных методов, таких как ```__init__()``` и ```__repr__()```, к пользовательским классам.

Модуль `dataclasses` позволяет создавать классы, которые больше напоминают структуру данных, чем объекты класса. Это делает их более удобными для использования в качестве контейнеров для данных.

#### 2. Декоратор dataclass и мотивация использования

Этот декоратор можно использовать для автоматического добавления сгенерированных специальных методов к классу. Это позволяяет избежать многократного повторения идентичного кода для инициализации полей класса, сравнения полей класса и т. д.

##### *Дополнительные замечания, не требующиеся для зачёта*

*По умолчанию, декоратор `dataclass` добавляет следующие методы:*

```Python
@dataclasses.dataclass(*, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True, kw_only=False, slots=False, weakref_slot=False)
```

*В течение семестра мы использовали:*

* *`__init__`: метод, инициализации экземпляра класса*
* *`__repr__`: метод, возвращающий строковое представление экземпляра класса*
* *`__eq__`: метод, сравнения экземпляров класса (==, и != по умолчанию как отрицание равенства)*
* *`__lt__`, `__le__`, `__gt__`, `__ge__` : методы сравнения экземпляров класса (<, <=, >, >=)*

## 5. Инкапсуляция в Python. Реализация геттеров и сеттеров с помощью декоратора ```@property```.

#### 1. Инкапсуляция в Python

Инкапсуляция - одна из основных принципов ООП. Это означает, что интерфейс и реализация должны быть разделены, а доступ к внутренним данным класса должен быть ограничен, чтобы защитить инвариант класса. Пользователь не должен знать о том, как устроен класс изнутри, и работать с ним, как с некой абстракцией. В Python инкапсуляция достигается с помощью приватных атрибутов (атрибутов, начинающихся с двойного или одинарного подчеркивания) и публичных методов.

Пример:

```Python
class Expample:
    a:str = "Public"        # доступен и внутри, и вне класса    
    _b:str = "Protecred"    # доступен только внутри класса и наследникам (по аналогии с с++)
    __c:str = "Private"     # доступен только внутри класса
```

На самом деле, приватные атрибуты в Python не являются приватными в полном смысле этого слова. Ко всем этим атрибутам *можно* (с большими или меньшими усилиями) получить доступ извне класса, но вам должно быть стыдно за такие нехорошие мысли.

#### 2. Реализация геттеров и сеттеров с помощью декоратора ```@property```

Для того, чтобы ограничить доступ к приватным атрибутам, мы можем использовать геттеры и сеттеры. Геттер - это метод, который возвращает значение приватного атрибута, а сеттер - метод, который изменяет значение приватного аттрибута, не позволяя напрямую обращаться к приватному атрибуту, тем самым обеспечивая инкапсуляцию.

Геттеры и сеттеры можно определить с помощью методов, но тогда их нужно вызывать как методы. Чтобы сделать их более удобными в использовании, мы можем использовать декоратор ```@property```, чтобы сделать их внешне неотличимыми от аттрибутов.

Пример:

```Python
from dataclasses import dataclass


@dataclass
class X:
    _x: float = 0

    @property
    def x(self) -> float:
        return self._x
    
    @x.setter
    def x(self, x_new: float) -> None:
        if not isinstance(x, (int, float)):
            raise TypeError("x must be a number") # sort of защиты инварианта
        self._x = float(x_new)

a = X(1)

print(a.x)  # 1

a.x = 7     # OK, теперь a.x == 7
a.x = "7"   # TypeError: x must be a number
```

## 6. Наследование в Python. Множественное наследование в Python. Суть проблемы ромба и MRO, как решение этой проблемы. Специальный объект super().

#### 1. Наследование в Python

Наследование - одна из ключевых концепций объектно-ориентированного программирования. Оно позволяет создавать новые классы, наследуя свойства и методы от уже существующих классов. Это позволяет избежать повторного написания кода и упрощает поддержку и расширение программ, ведь мы можем расширить существующий класс, не меняя его исходный код.

Пример:

```Python
class Сhild (Parent, ...):
    pass

# Child - дочерний класс, сабкласс
# Parent - родительский класс, базовый класс, супер класс
```

При наследовании класса Сhild от класса Parent, Сhild наследует все свойства и методы Parent, а также может добавлять свои собственные свойства и методы.

#### 2. Множественное наследование в Python

Если у нас есть несколько родительских классов, мы можем наследовать от них одновременно. Это называется множественным наследованием. При множественном наследовании сабкласс наследует свойства и методы всех супер классов.

#### 3. Суть проблемы ромба и MRO, как решение этой проблемы

При множественном наследовании возникает проблема, известная как *"проблема ромба"*.

"Проблема ромба" заключается в следующем: предположим у нас есть некоторый класс, который обладает некоторым методом. Для конкретики представим, что имеется класс ```Parallelogram```, у которого есть метод ```area```. У данного супер класса есть два сабкласса ```Rectangle``` и ```Rhombus```, которые переопределяют метод ```area``` исходного класса. Также есть класс ```Square```, который является сабклассом и для класса ```Rectangle```, и для класса ```Rhombus```. Мы создаем экземпляр класса Square и вызываем у него метод area, метод какого класса будет вызван?

Подобная неопределённасть является проблемой, поскольку она может привести к неожиданным результатам.

Во избежание этой проблемы, Python использует механизм MRO (Method Resolution Order). MRO определяет порядок вызова методов в дочернем классе. Он гарантирует, что методы родительских классов будут вызываться в правильном порядке, даже если у нас есть множественное наследование.

Пример:

```Python
class Parallelogram:
    def area(self) -> None:
        print('parallelogram area')


class Rectangle(Parallelogram):
    def area(self) -> None:
        print('rectangle area')


class Rhombus(Parallelogram):
    def area(self) -> None:
        print('rhombus area')


class Square(Rectangle, Rhombus):
    pass


square = Square()
square.area()       # rectangle area

print(Square.__mro__) 
# (<class '__main__.Square'>, <class '__main__.Rectangle'>,
# <class '__main__.Rhombus'>, <class '__main__.Parallelogram'>, <class 'object'>)
```

Итак, при попытке вызвать метод ```area``` у экземпляра класса ```Square```, интерпретатор пытается найти переопределяющий дескрипток в классе ```Square```. Поскольку класс ```Square``` не содержит в себе подобного дескриптора, интерпретатор пытается найти имя area в атрибуте ```__dict__``` экземпляра класса ```Square```. Но данный атрибут пуст. Тогда интерпретатор пытается найти указанное имя в атрибуте ```__dict__``` самого класса ```Square```, но и этот атрибут не содержит нужного имени. Тогда интерпретатор начинает поиск в следующем элементе кортежа ```__mro__```, т.е. в классе ```Rectangle```. Атрибут ```__dict__``` данного класса содержит искомое имя, интерпретатор использует найденное в ```Rectangle``` значение для имени area в качестве результата поиска, а сам поиск на этом завершается.

Но почему классы в атрибуте ```__mro__``` расположены именно в такой последовательности? И что в этом кортеже делает класс ```object```?

* Ответ на первый вопрос достаточно сложный, однако, если упростить алгоритм обхода графа наследования, то он будет представлять из себя следующую конструкцию. Чем ближе суперклассы к сабклассу в графе наследования, тем левее они будут находится в кортеже ```__mro__```, более того, при множественном наследовании, классы, указанные левее, будут располагаться левее и в ```__mro__```. Собственно, это явно и илюстрирует полученный кортеж. Классы, от которых мы наследовались напрямую, расположены ближе к левой границе массива. При этом, порядок их расположения соответствует порядку из следования в области наследования при определении нашего класса ```Square```.

* Ответ на второй вопрос состоит в следующем: даже при отсутствии наследования, все объекты Python неявно наследуются от встроенного типа данных ```object```, который описывает объекты Python.

#### 4. Специальный объект super()

super() — это объект, который позволяет получить доступ к методам родительского класса. Это позволяет не держать в голове граф обхода наследования и не писать длинные цепочки вызовов методов родительских классов. Эта функция необходима при реализации ```__init__``` сабкласса, поскольку реализация ```__init__``` в сабклассе перекрывает ```__init__``` в суперклассе.

Пример:

```Python
class Parent:
    def __init__(self) -> None:
        print('init Parent')


class ChildWrong(Parent):
    def __init__(self) -> None:
        print('init ChildWrong')


class ChaildNaive(Parent):
    pass


class ChildGood(Parent):
    def __init__(self) -> None:
        super().__init__()
        print('init ChildGood')


child_wrong = ChildWrong()  # init ChildWrong

child_naive = ChaildNaive() # init Parent

child_good = ChildGood()    # init Parent init ChildGood
```

Важно помнить, что super() прервёт обход графа наследования, если в текущем классе есть метод с подходящим именем.

Пример:

```Python
class A:
    def __init__(self) -> None:
        print('init A')


class B:
    def __init__(self) -> None:
        print('init B')


class bad_C(A, B):
    def __init__(self) -> None:
        super().__init__()
        print('init C')


class good_C(A, B):
    def __init__(self) -> None:
        A.__init__(self)
        B.__init__(self)
        
        print('init C')


a = bad_C()
# init A
# init C

b = good_C()
# init A
# init B
# init C
```

## 7. Полиморфизм в Python

#### 1. Полиморфизм в Python

Полиморфизм - одна из ключевых концепций объектно-ориентированного программирования. Он заключается в унификации точки входа в определенную операцию для разных типов данных или комбинаций аргементов. Мы уже знакомы с полиморфизмом на примере вногих втроенных функций. Ярким примером может быть функция ```len()```. Данная функция способна принимать на вход список, кортеж, словарь, любой объект, реализующий функцию ```__len__()```. Т.е. это единая точка входа в операции определения размера для объектов различных типов данных.

В ООП под полиморфизмом обычно понимают полиморфизм классов. Т.е. наличие в классах методов с одинаковыми сигнатурами, однако реализующими операции, исходя из логики самого класса.

Подобный полиморфизм классов приводит нас к понятию *протоколов*. Говоря о протаколе, мы подразумеваем, что объект реализует некоторый функционал, позволяющий использовать его в определённом контексте. Например, мы знакомы с вами с протоколом последовательностей. Когда мы говорили, что объект является последовательностью, мы подразумевали, что он ведет себя как последовательсноть, т.е. поддерживает определенный набор операций.

Понятие протокола является неформальным, это значит, что обычно нам не приходится проверять соответствие объекта определенному типу данных. Вместо этого мы просто пытаемся работать с полученным объектом, как с представителем данного протокола. Если у нас получается обработать его нужным образом - хорошо, не получается - значит объект не удовлетворял требуемому протоколу.

Ярким примером данного принципа может служить стремление интерпретатора обрабатывать объект, частично реализующий протокол последовательности, как последовательность:

```Python
from typing import Iterable, Union, Any


class MySequence:
    _iterable: list

    def __init__(self, iterable: Iterable) -> None:
        self._iterable = list(iterable)

    def __getitem__(self, index: Union[int, slice]) -> Any:
        return self._iterable[index]

my_seq = MySequence((1, 2, 3, 4))

for elem in my_seq:
    print(elem)
```

## 8. Абстракция в Python. Модуль стандартной библиотеки ```abc```. Примеры и мотивация использования.

#### 1. Абстракция в Python

Последняя концепция ООП - это абстракция. Абстракция - это выделение в моделируемом предмете важного для решения конкретной задачи. Абстракции являются более формальными протоколами, посколько они строго определены. Если, как мы видели выше, для обработки объекта по протоколу последовательностей не требуется строгого соответствия протоколу последовательности, то при разработке абстракций, от объекта, наследующего некоторый абстрактный интерфейс, требуется четкое соответствие ему.

Для реализации абстракций в коде используют абстрактные базовые классы. Это специальные классы, которые описывают четкий интерфес взаимодействия с объектами, но при этом не реализующие его. Создать экземпляр абстрактного класса невозможно.

Абстрактные базовые классы и чистые интерфейсы - это большая редкость в Python. Большая часть объектов реализуются как представители определнных протоколов. На практике, вам вряд ли придется реализовывать свой абстрактный базовый класс.

#### 2. Модуль стандартной библиотеки ```abc```

Python предоставляет модуль ```abc``` для работы с абстрактными базовыми классами. Этот модуль позволяет создавать абстрактные базовые классы и наследники, а также проверять, является ли класс абстрактным или нет. Для создания абстрактного класса необходимо наследоваться от класса ```ABC``` и использовать декоратор ```@abstractmethod``` для определения виртуальных методов.

#### 3. Примеры и мотивация использования

Пример:

```Python
import abc


class Polygon(abc.ABC):
    @abc.abstractmethod
    def area(self) -> float:
        ...


class Square(Polygon):
    _side_len: float

    def __init__(self, side_len: float) -> None:
        self._side_len = float(side_len)

    def area(self) -> float:
        return self._side_len ** 2
    
    @property
    def side_len(self) -> float:
        return self._side_len
    

class Rectangle(Polygon):
    _length: float
    _width: float

    def __init__(self, length: float, width: float) -> None:
        self._length = float(length)
        self._width = float(width)

    def area(self) -> float:
        return self._length * self._width
    
    @property
    def length(self) -> float:
        return self._length
    
    @property
    def width(self) -> float:
        return self._width


square = Square(4)
rectangle = Rectangle(3, 5)

print(f'square: {square.area()}; rect: {rectangle.area()};') # square: 16.0; rect: 15.0;

polygon = Polygon() # TypeError: Can't instantiate abstract class Polygon with abstract methods area
```

Абстрактный базовый класс не подерживает создание экземпляров. Абстрактный базовый класс может включать как обычные методы, так и чисто виртуальные методы, как в данном примере. При этом, если абстрактный базовый класс включает в себя методы с реализацией, то реализация должна состоять только из вызовов методов описываемого интерфейса, без ограничения возможностей внутренний реализации объектов. Классы, наследующиеся от абстрактного базового класса обязаны реализовать в себе чисто виртуальные методы, иначе итерпретатор будет считать их виртуальными классами и не позволит создавать экземпляры. При этом, классы наследники могут дополнять интерфейс исходного базового класса.

Мотивация использования абстрактных классов заключается в следующем:

* Упрощение сложности. Абстракция позволяет скрыть детали реализации и сосредоточиться на ключевых аспектах системы. Это помогает упростить понимание и поддержку кода.
* Модульность. Возможность разбить систему на модули или классы, которые могут работать независимо друг от друга. Это способствует повторному использованию кода и улучшает масштабируемость проекта.
* Повышение безопасности. Абстракция позволяет скрыть некоторые детали реализации, что делает код более безопасным и защищенным. Внешние компоненты не имеют прямого доступа к внутренним деталям объекта или системы.
* Гарантия того, что в наследуемых классах будет реализован метод с тем же названием и похожим функционалом.
* Гибкость. Возможность заменить реализацию компонента на другую, просто передав в метод другой дочерний объект абстрактного класса.

## 9. Протоколы. Протоколы, как пример структурного подтипирования. Протокол контекстного менеджера.

#### 1. Протоколы

Протоколы — это альтернатива абстрактным базовым классам (abstract base classes, ABC). Они позволяют пользоваться структурной подтипизацией (structural subtyping), то есть — осуществлять проверку совместимости классов исключительно на основе анализа их атрибутов и методов.

#### Подтипирование

В Python существует два типа подтипирования:

* *Номинальное подтипирование*. Основано на иерархии классов. Например, если класс ```Dog``` наследует класс ```Animal```, то он является подтипом ```Animal```, и его можно использовать везде, где требуется ```Animal```.

* *Структурное подтипирование*. Основано на операциях, которые можно выполнить с объектом. Класс ```Dog``` является структурным подтипом класса ```Animal```, если первый имеет все атрибуты и методы второго, при этом с совместимыми типами. Тогда ```Dog``` можно использовать везде, где требуется ```Animal```.

```Python
# пример структурного подтипирования
def add(x, y):
    return x + y

print(add(2, 3))            # 5
print(add("str1", "str2"))  # str1str2
```

#### 2. Протокол контекстного менеджера

Классы, реализующие протокол контекстного менеджера, должны иметь методы ```__enter__``` и ```__exit__```. Метод ```__enter__``` вызывается перед началом блока, а метод ```__exit__``` — после его окончания. Если в блоке возникает исключение, метод ```__exit__``` вызывается с этим исключением в качестве аргумента.

Такие классы можно использовать в контекстных выражениях, которые позволяют выполнять блок кода:

```Python
class MyContextManager:
    def __enter__(self) -> None:
        print("call __enter__")
    def __exit__(self, exc_type, exc_value, exc_tb) -> bool:
        print("call __exit__")
        if isinstance(exc_value, ValueError):
        return True

with MyContextManager():
    raise ValueError()

# call __enter__
# call __exit__
```

## 10. Эмуляция числовых типов данных за счет определения некоторых специальных арифметических и логических методов.

Используя специальные методы, можно эмулировать числовые типы данных.

Для этого необходимо определить методы, соответствующие арифметическим и логическим операциям. Например:

* ```__bool__``` : возвращает булевое представление экземпляра класса. Можно использовать в виде ```bool()```. Обязан возвращать ```bool```.

* ```__eq__```, ```__ne__``` : определяют, что экземпляр класса можно сравнивать с другим экземпляром класса. Используются в виде ```==``` и ```!=```. Если определить только ```__eq__```, то ```__ne__``` будет вызываться автоматически, как отрицание ```__eq__```.

* ```__abs__``` : позволяет использовать ```abs()```.

* ```__neg__``` : позволяет использовать унарный минус.

* Операции сравнения ```__lt__```, ```__le__```, ```__gt__```, ```__ge__```.

* Преобразования типа

* Битовые операторы

* Округления

* Составное присваивание

Также можно определить методы для бинарных арифметических операций (см. следующий билет).

## 11. Бинарные арифметические операции. Объект NotImplemented. Определение прямых и отраженных арифметических операций. Порядок выполнения бинарных арифметических операций интерпретатором.

#### 1. Бинарные фрифметические операции

Бинарные арифметические операции — это операции, которые принимают два аргумента и возвращают результат. Например, сложение, вычитание, умножение, деление. Чтобы определить эти операции, необходимо определить методы, соответствующие этим операциям. Например:

* ```__add__```, ```__radd__``` : '+'

* ```__sub__```, ```__rsub__``` : '-'

* ```__mul__```, ```__rmul__``` : '*'

* ```__truediv__```, ```__rtruediv__``` : '/'

Также операции степени, различные формы деления и т.п.

#### 2. Объект NotImplemented. Порядок выполнения бинарных арифметических операций интерпретатором.

Бинарные арифметические операции могут возвращать объект NotImplemented, если операция не определена. В этом случае интерпретатор будет пытаться вызывать метод инвертированной операции у второго объекта.

#### 3. Определение прямых и отраженных арифметических операций

Чтобы обеспечить корректную работу бинарных арифметических операций, необходимо определить как прямые, так и отраженные операции. Прямая операция — это операция, которая вызывается у первого объекта, а отраженная операция — это операция, которая вызывается у второго объекта.

## 12. Определение методов для преобразования объекта в числовые типы данных.

Методы ```__int__```, ```__float__```, ```__complex__``` : преобразуют объект в соответствующий числовой тип данных.

Их можно использовать в виде функций ```int()```, ```float()```, ```complex()```.

## 13. Протоколы контейнера и объекта с размером (```Container``` и ```Sized```). Ограничения  метода  ```__len__```. Определение  метода  ```__bool__``` через ```__len__```.

#### 1. Протоколы контейнера и объекта с размером

* Чтобы объект соответствовал протоколу контейнера, необходимо определить метод ```__contains__```, определяющий, содержится ли в объекте заданный элемент.

* Чтобы объект соответствовал протоколу объекта с размером, необходимо определить метод ```__len__```, возвращающий размер объекта.

#### 2. Ограничения метода ```__len__```

```__len__``` всегда должен возвращать значение, которое является неотрицательным целым числом.

#### 3. Определение метода ```__bool__``` через ```__len__```

Если для объекта определён метод ```__len__```, то интерпретатор будет использовать его для определения значения ```__bool__``` как ```bool(len(object))``` если метод  ```__bool__``` не реализован.

## 14. Протокол итерируемого объекта и итератора. Встроенные функции ```next()``` и ```iter()```. Исключение ```StopIteration```. Примеры реализации итерируемого объекта и итератора. Определение оператора ```in``` с помощью итерируемости.

#### 1. Протокол итерируемого объекта и итератора

* Чтобы объект соответствовал протоколу итерируемого, необходимо определить метод ```__iter__```, возвращающий итератор для объекта.

* Чтобы объект соответствовал протоколу итератора, необходимо определить метод ```__next__```, возвращающий следующий элемент из объекта.

#### 2. Встроенные функции next и iter

Методы ```__iter__``` и ```__next__``` можно вызывать с помощью встроенных функций ```iter()``` и ```next()```.

#### 3. Исключение StopIteration

Если итератор достигает конца итерируемого объекта, он должен выбрасывать исключение ```StopIteration```/

#### 4. Примеры реализации итерируемого объекта и итератора

```Python
class MyIterator:
    a = 0

    def __next__(self):
        if self.a < 5:
            result = self.a
            self.a += 1
            return result
        raise StopIteration

class MyIterable:
    def __iter__(self):
        return MyIterator()


for i in MyIterable():
    print(i, end=' ') # 0 1 2 3 4
```

#### Определение оператора ```in``` с помощью итерируемости

Если для объекта определён метод ```iter()```, но не определён метод ```__contains__```, то интерпретатор будет использовать методом ```iter()``` для определения значения оперфтора ```in``` как ```x in y``` эквивалентно ```any(x == i for i in iter(y))```.

## 15. Протокол коллекции. Определение операций чтения, перезаписи и удаления элементов коллекции. Определение итерируемости через метод ```__getitem__```.

*Примечание от составителя:*

*Полагаю, здесь произошла небольшая ошибка, и, скорее всего, имелся ввиду протокол коллекции, а не контейнера.*

#### 1. Протокол коллекции

Чтобы объект соответствовал протоколу коллекции, необходимо, чтобы он соответствовал протоколам итерируемого объекта, контейнера и объекта с длиной, т.е. всем трем протоколам, перечисленным выше.

#### 2. Определение операций чтения, перезаписи и удаления элементов коллекции

* Метод ```__getitem__``` определяет операцию чтения чтения элемента коллекции по индексу.
* Метод ```__setitem__``` определяет операцию перезаписи элемента коллекции по индексу.
* Метод ```__delitem__``` определяет операцию удаления элемента коллекции по индексу.

Все эти методы имеют сигнатуру ...(self, key: int).

#### 3. Определение итерируемости через метод ```__getitem__```.

Если в классе не был определён метод ```__iter__```, но был определён метод ```__getitem__```, то интерпретатор будет использовать метод ```__getitem__``` чтобы определить итерируемость объекта. Интерпретатор будет полседовательно вызывать метод ```__getitem__``` с возрастающим значением ключа, пока не будет достигнут ключ, который не существует в коллекции и не будет выброшено исключение `IndexError`. 

## 16. Генераторные  функции  и  генераторы.  Мотивация  и  примеры использования.  Ключевое  слово  ```yield```. Разница  между итерируемым  объектом,  итератором  и  генератором. Генераторные выражения и включения.

#### 1. Генераторные функции и генераторы

Генераторные функции - это функции, содержащие ключевое слово ```yield``` и возвращающие генератор, который является итератором, т.е. объектом, поддерживающим протокол итератора (к нему можно применить ```next()```).

#### 2. Мотивация и примеры использования

Генераторы позволяют создавать неограниченные итерируемые объекты, которые могут хранить в себе только текущее значение, что ведёт к значительной экономии памяти.

Пример:

```Python
def my_generator(): # генераторная функция, создающая "бесконечную" последовательность натуральных чисел
    a = 0
    while True:
        yield a
        a += 1
```

#### 3. Ключевое слово ```yield```

```yield``` - ключевое слово, которое позволяет функции возвращать значение, а затем продолжать выполнение после точки, где оно было вызвано. Это позволяет функции генерировать значения, не храня их в памяти. С помощью него создаются генераторные функции.

#### 4. Разница между итерируемым объектом, итератором и генератором

Итерируемый объект может порождать итераторы, а генераторы является и итерируемыми объектами, и итераторами.

#### 5. Генераторные выражения и включения

По аналогии со списковыми и словарными включениями, вы можете создавать простые генераторы с помощью генераторных выражений. В качестве примера использования генераторных выражений, давайте вычислим сумму квадратов чисел от 0 до 9 с помощью списковых и генераторных включений:

```Python
# Списковое включение
sum_of_squares = sum([i**2 for i in range(10)])
# Генераторное включение
sum_of_squares = sum(i**2 for i in range(10))
```

## 17. Встроенные объекты, производящие генераторы: range,  enumerate, zip, map. Примеры использования.

* ```range()``` : ```range``` является специальным встроенным объектом. При использовании его в цикле ```for```, ```range``` возвращает генератор, пораждающий числа из заданного диапазона с заданным шагом, который по умолчанию равен 1.

```Python
a = [i for i in range(10)] # создание списка из 10 целых чисел
```

* ```enumerate()``` : Аналогично ```range```, ```enumerate``` является встроенным типом данных, позволяющих конструировать специальные объекты. При использовании этих объектов в циклах ```for```, они возвращают генераторы, пораждающие пары вида <индекс, значение>.

Пример:

```Python
for i, elem in enumerate(range(5), start=1):
    print(f'elem_{i}: {elem}')

# Вывод:
# elem_1: 0
# elem_2: 1
# elem_3: 2
# elem_4: 3
# elem_5: 4
```

* ```zip``` - позволяет получит итератор, i-ый элементы которого - кортеж, содержащий i-е элементы переданных итерируемых объектов. При несоответствии длин итерируемых объектов, zip ведет себя подобно map, обрезая все по длине кратчайшей последовательности.

Использование zip может быть проиллюстрировано вычислением манхеттенского расстояния между векторами:

```Python
from random import randint


vector1 = [randint(-10, 10) for _ in range(10)]
vector2 = [randint(-10, 10) for _ in range(10)]

# вычисление манхеттенского расстояния
distance = sum(abs(x_1 - x_2) for x_1, x_2 in zip(vector1, vector2))

print(f'{distance = }')
```

* ```map``` - позволяет построить итерируемый объект, содержащий результат применения переданной функции, к переданным итерируемым объектам.

```Python
a = list(map(int, input().split())) # преобразование строки в список целых чисел
```

## P.S.
Если ты дошел до сюда честным путем - то поздравляю! Ты сдашь питон на отл10! Удачи тебе, физтех!